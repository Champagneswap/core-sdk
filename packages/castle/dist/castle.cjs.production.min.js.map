{"version":3,"file":"castle.cjs.production.min.js","sources":["../src/Utils.ts","../src/Graph.ts","../src/PrimaryPools.ts","../src/CLPool.ts","../src/deprecated/MultiRouterTypes.ts","../src/MultiRouter.ts","../src/deprecated/MultiRouterMath.ts"],"sourcesContent":["import { BigNumber } from \"@ethersproject/bignumber\";\n\nexport function ASSERT(f: () => boolean, t?: string) {\n    if (!f() && t) console.error(t);\n  }\n  \n  export function closeValues(a: number, b: number, accuracy: number): boolean {\n    if (accuracy === 0) return a === b;\n    if (a < 1 / accuracy) return Math.abs(a - b) <= 10;\n    return Math.abs(a / b - 1) < accuracy;\n  }\n  \n  export function calcSquareEquation(\n    a: number,\n    b: number,\n    c: number\n  ): [number, number] {\n    const D = b * b - 4 * a * c;\n    console.assert(D >= 0, `Discriminant is negative! ${a} ${b} ${c}`);\n    const sqrtD = Math.sqrt(D);\n    return [(-b - sqrtD) / 2 / a, (-b + sqrtD) / 2 / a];\n  }\n  \n  // returns such x > 0 that f(x) = out or 0 if there is no such x or f defined not everywhere\n  // hint - approximation of x to spead up the algorithm\n  // f assumed to be continues monotone growth function defined everywhere\n  export function revertPositive(\n    f: (x: number) => number,\n    out: number,\n    hint = 1\n  ) {\n    try {\n      if (out <= f(0)) return 0;\n      let min, max;\n      if (f(hint) > out) {\n        min = hint / 2;\n        while (f(min) > out) min /= 2;\n        max = min * 2;\n      } else {\n        max = hint * 2;\n        while (f(max) < out) max *= 2;\n        min = max / 2;\n      }\n  \n      while (max / min - 1 > 1e-4) {\n        const x0: number = (min + max) / 2;\n        const y0 = f(x0);\n        if (out === y0) return x0;\n        if (out < y0) max = x0;\n        else min = x0;\n      }\n      return (min + max) / 2;\n    } catch (e) {\n      return 0;\n    }\n  }\n  \n  export function getBigNumber(\n    value: number\n  ): BigNumber {\n    const v = Math.abs(value)\n    if (v < Number.MAX_SAFE_INTEGER) return BigNumber.from(Math.round(value));\n  \n    const exp = Math.floor(Math.log(v) / Math.LN2);\n    console.assert(exp >= 51, \"Internal Error 314\");\n    const shift = exp - 51;\n    const mant = Math.round(v / Math.pow(2, shift));\n    const res = BigNumber.from(mant).mul(BigNumber.from(2).pow(shift));\n    return value > 0 ? res : res.mul(-1);\n  }\n  ","import { BigNumber } from \"@ethersproject/bignumber\";\nimport { RPool, RToken } from \"./PrimaryPools\";\nimport {ASSERT, getBigNumber, closeValues} from \"./Utils\";\n\n// Routing info about each one swap\nexport interface RouteLeg {\n  poolAddress: string       // which pool use for swap\n  poolFee: number\n\n  tokenFrom: RToken         // from what token to swap\n  tokenTo: RToken           // to what token \n\n  assumedAmountIn: number   // assumed number of input token for swapping\n  assumedAmountOut: number  // assumed number of output token after swapping\n\n  swapPortion: number       // for router contract\n  absolutePortion: number   // to depict at webpage for user\n}\n\nexport enum RouteStatus {\n  Success = \"Success\",\n  NoWay = \"NoWay\",\n  Partial = \"Partial\",\n}\n\nexport interface MultiRoute {\n  status: RouteStatus;\n  fromToken: RToken;\n  toToken: RToken;\n  primaryPrice?: number;\n  swapPrice?: number;\n  priceImpact?: number;\n  amountIn: number;\n  amountInBN: BigNumber;\n  amountOut: number;\n  amountOutBN: BigNumber;\n  legs: RouteLeg[];\n  gasSpent: number;\n  totalAmountOut: number;\n  totalAmountOutBN: BigNumber;\n}\n\nexport class Edge {\n  pool: RPool;\n  vert0: Vertice;\n  vert1: Vertice;\n\n  canBeUsed: boolean;\n  direction: boolean;\n  amountInPrevious: number;   // How many liquidity were passed from vert0 to vert1\n  amountOutPrevious: number;  // How many liquidity were passed from vert0 to vert1\n  spentGas: number            // How much gas was spent for this edge\n  spentGasNew: number         //  How much gas was will be spent for this edge\n  bestEdgeIncome: number;     // debug data\n\n\n  constructor(p: RPool, v0: Vertice, v1: Vertice) {\n    this.pool = p;\n    this.vert0 = v0;\n    this.vert1 = v1;\n    this.amountInPrevious = 0;\n    this.amountOutPrevious = 0;\n    this.canBeUsed = true;\n    this.direction = true;\n    this.spentGas = 0;\n    this.spentGasNew = 0;\n    this.bestEdgeIncome = 0;\n  }\n\n  cleanTmpData() {\n    this.amountInPrevious = 0;\n    this.amountOutPrevious = 0;\n    this.canBeUsed = true;\n    this.direction = true;\n    this.spentGas = 0;\n    this.spentGasNew = 0;\n    this.bestEdgeIncome = 0;\n  }\n\n  reserve(v: Vertice): BigNumber {\n    return v === this.vert0 ? this.pool.reserve0 : this.pool.reserve1\n  }\n\n  calcOutput(v: Vertice, amountIn: number): {out: number, gasSpent: number} {\n    let res, gas;\n    if (v === this.vert1) {\n      if (this.direction) {\n        if (amountIn < this.amountOutPrevious) {\n          const {inp, gasSpent} = this.pool.calcInByOut(this.amountOutPrevious - amountIn, true)\n          res = this.amountInPrevious - inp\n          gas = gasSpent\n        } else {\n          const {out, gasSpent} = this.pool.calcOutByIn(amountIn - this.amountOutPrevious, false)\n          res = out + this.amountInPrevious\n          gas = gasSpent\n        }\n      } else {\n        const {out, gasSpent} = this.pool.calcOutByIn(this.amountOutPrevious + amountIn, false)\n        res = out - this.amountInPrevious;\n        gas = gasSpent\n      }\n    } else {\n      if (this.direction) {\n        const {out, gasSpent} = this.pool.calcOutByIn(this.amountInPrevious + amountIn, true)\n        res = out - this.amountOutPrevious\n        gas = gasSpent\n      } else {\n        if (amountIn < this.amountInPrevious) {\n          const {inp, gasSpent} = this.pool.calcInByOut(this.amountInPrevious - amountIn, false)\n          res = this.amountOutPrevious - inp\n          gas = gasSpent\n        } else {\n          const {out, gasSpent} = this.pool.calcOutByIn(amountIn - this.amountInPrevious, true)\n          res = out + this.amountOutPrevious\n          gas = gasSpent\n        }\n      }\n    }\n\n    // this.testApply(v, amountIn, out);\n\n    return {out: res, gasSpent: gas - this.spentGas};\n  }\n\n  calcInput(v: Vertice, amountOut: number): {inp: number, gasSpent: number}  {\n    let res, gas;\n    if (v === this.vert1) {\n      if (!this.direction) {\n        if (amountOut < this.amountOutPrevious) {\n          const {out, gasSpent}  = this.pool.calcOutByIn(this.amountOutPrevious - amountOut, false)\n          res = this.amountInPrevious - out\n          gas = gasSpent\n        } else {\n          const {inp, gasSpent} = this.pool.calcInByOut(amountOut - this.amountOutPrevious, true)\n          res = inp + this.amountInPrevious\n          gas = gasSpent\n        }\n      } else {\n        const {inp, gasSpent} = this.pool.calcInByOut(this.amountOutPrevious + amountOut, true)\n        res = inp - this.amountInPrevious\n        gas = gasSpent\n      }\n    } else {\n      if (!this.direction) {\n        const {inp, gasSpent} = this.pool.calcInByOut(this.amountInPrevious + amountOut, false)\n        res = inp - this.amountOutPrevious\n        gas = gasSpent\n      } else {\n        if (amountOut < this.amountInPrevious) {\n          const {out, gasSpent} = this.pool.calcOutByIn(this.amountInPrevious - amountOut, true)\n          res = this.amountOutPrevious - out\n          gas = gasSpent\n        } else {\n          const {inp, gasSpent} = this.pool.calcInByOut(amountOut - this.amountInPrevious, false)\n          res = inp + this.amountOutPrevious\n          gas = gasSpent\n        }\n      }\n    }\n\n    // this.testApply(v, amountIn, out);\n\n    return {inp: res, gasSpent: gas - this.spentGas};\n  }\n\n  checkMinimalLiquidityExceededAfterSwap(from: Vertice, amountOut: number): boolean {\n    if (from === this.vert0) {\n      const r1 = parseInt(this.pool.reserve1.toString())\n      if (this.direction) {\n        return r1 - amountOut - this.amountOutPrevious < this.pool.minLiquidity;\n      } else {\n        return r1 - amountOut + this.amountOutPrevious < this.pool.minLiquidity;\n      }\n    } else {\n      const r0 = parseInt(this.pool.reserve0.toString())\n      if (this.direction) {\n        return r0 - amountOut + this.amountInPrevious < this.pool.minLiquidity;\n      } else {\n        return r0 - amountOut - this.amountInPrevious < this.pool.minLiquidity;\n      }\n    }\n  }\n\n  // doesn't used in production - just for testing\n  testApply(from: Vertice, amountIn: number, amountOut: number) {\n    console.assert(this.amountInPrevious * this.amountOutPrevious >= 0)\n    const inPrev = this.direction ? this.amountInPrevious : -this.amountInPrevious\n    const outPrev = this.direction ? this.amountOutPrevious : -this.amountOutPrevious\n    const to = from.getNeibour(this)\n    let directionNew,\n      amountInNew = 0,\n      amountOutNew = 0\n    if (to) {\n      const inInc = from === this.vert0 ? amountIn : -amountOut\n      const outInc = from === this.vert0 ? amountOut : -amountIn\n      const inNew = inPrev + inInc\n      const outNew = outPrev + outInc\n      if (inNew * outNew < 0) console.log('333')\n      console.assert(inNew * outNew >= 0)\n      if (inNew >= 0) {\n        directionNew = true\n        amountInNew = inNew\n        amountOutNew = outNew\n      } else {\n        directionNew = false\n        amountInNew = -inNew\n        amountOutNew = -outNew\n      }\n    } else console.error('Error 221')\n\n    if (directionNew) {\n      const calc = this.pool.calcOutByIn(amountInNew, true).out;\n      const res = closeValues(amountOutNew, calc, 1e-6);\n      if (!res)\n        console.log(\n          \"Err 225-1 !!\",\n          amountOutNew,\n          calc,\n          Math.abs(calc / amountOutNew - 1)\n        );\n      return res;\n    } else {\n      const calc = this.pool.calcOutByIn(amountOutNew, false).out;\n      const res = closeValues(amountInNew, calc, 1e-6);\n      if (!res)\n        console.log(\n          \"Err 225-2!!\",\n          amountInNew,\n          calc,\n          Math.abs(calc / amountInNew - 1)\n        );\n      return res;\n    }\n  }\n\n  applySwap(from: Vertice) {\n    console.assert(this.amountInPrevious * this.amountOutPrevious >= 0)\n    const inPrev = this.direction ? this.amountInPrevious : -this.amountInPrevious\n    const outPrev = this.direction ? this.amountOutPrevious : -this.amountOutPrevious\n    const to = from.getNeibour(this)\n    if (to) {\n      const inInc = from === this.vert0 ? from.bestIncome : -to.bestIncome\n      const outInc = from === this.vert0 ? to.bestIncome : -from.bestIncome\n      const inNew = inPrev + inInc\n      const outNew = outPrev + outInc\n      console.assert(inNew * outNew >= 0)\n      if (inNew >= 0) {\n        this.direction = true\n        this.amountInPrevious = inNew\n        this.amountOutPrevious = outNew\n      } else {\n        this.direction = false\n        this.amountInPrevious = -inNew\n        this.amountOutPrevious = -outNew\n      }\n    } else console.error(\"Error 221\");\n    this.spentGas = this.spentGasNew\n\n    ASSERT(() => {\n      if (this.direction)\n        return closeValues(\n          this.amountOutPrevious,\n          this.pool.calcOutByIn(this.amountInPrevious, this.direction).out,\n          1e-6\n        );\n      else {\n        return closeValues(\n          this.amountInPrevious,\n          this.pool.calcOutByIn(this.amountOutPrevious, this.direction).out,\n          1e-6\n        );\n      }\n    }, `Error 225`)\n  }\n}\n\nexport class Vertice {\n  token: RToken\n  edges: Edge[]\n\n  price: number\n  gasPrice: number\n\n  bestIncome: number // temp data used for findBestPath algorithm\n  gasSpent: number // temp data used for findBestPath algorithm\n  bestTotal: number // temp data used for findBestPath algorithm\n  bestSource?: Edge // temp data used for findBestPath algorithm\n  checkLine: number // debug data\n\n  constructor(t: RToken) {\n    this.token = t\n    this.edges = []\n    this.price = 0\n    this.gasPrice = 0\n    this.bestIncome = 0\n    this.gasSpent = 0\n    this.bestTotal = 0\n    this.bestSource = undefined\n    this.checkLine = -1\n  }\n\n  cleanTmpData() {\n    this.bestIncome = 0\n    this.gasSpent = 0\n    this.bestTotal = 0\n    this.bestSource = undefined\n    this.checkLine = -1\n  }\n\n  getNeibour(e?: Edge) {\n    if (!e) return\n    return e.vert0 === this ? e.vert1 : e.vert0\n  }\n\n  getOutputEdges(): Edge[] {\n    return this.edges.filter((e) => {\n      if (!e.canBeUsed) return false\n      if (e.amountInPrevious === 0) return false\n      if (e.direction !== (e.vert0 === this)) return false\n      return true\n    })\n  }\n\n  getInputEdges(): Edge[] {\n    return this.edges.filter((e) => {\n      if (!e.canBeUsed) return false\n      if (e.amountInPrevious === 0) return false\n      if (e.direction === (e.vert0 === this)) return false\n      return true\n    })\n  }\n}\n\nexport class Graph {\n  vertices: Vertice[]\n  edges: Edge[]\n  tokens: Map<string, Vertice>\n\n  constructor(pools: RPool[], baseToken: RToken, gasPrice: number) {\n    this.vertices = [];\n    this.edges = [];\n    this.tokens = new Map();\n    pools.forEach((p) => {\n      const v0 = this.getOrCreateVertice(p.token0)\n      const v1 = this.getOrCreateVertice(p.token1)\n      const edge = new Edge(p, v0, v1)\n      v0.edges.push(edge)\n      v1.edges.push(edge)\n      this.edges.push(edge)\n    })\n    const baseVert = this.tokens.get(baseToken.address)\n    if (baseVert) {\n      this.setPricesStable(baseVert, 1, gasPrice)\n    }\n  }\n\n  cleanTmpData() {\n    this.edges.forEach(e => e.cleanTmpData())\n    this.vertices.forEach(v => v.cleanTmpData())\n  }\n\n  // Set prices by greedy algorithm\n  setPricesStable(from: Vertice, price: number, gasPrice: number) {\n    this.vertices.forEach(v => v.price = 0) // initialization\n    from.price = price\n    from.gasPrice = gasPrice\n    \n    const edgeValues = new Map<Edge, number>()\n    const value = (e: Edge): number => edgeValues.get(e) as number\n    \n    function addVertice(v: Vertice) {\n      const newEdges = v.edges.filter(e => v.getNeibour(e)?.price == 0)\n      newEdges.forEach(e => edgeValues.set(e, v.price*parseInt(e.reserve(from).toString())) )\n      newEdges.sort((e1, e2) => value(e1) - value(e2))\n      const res: Edge[] = []\n      while (nextEdges.length && newEdges.length) {\n        if (value(nextEdges[0]) < value(newEdges[0])) res.push(nextEdges.shift() as Edge)  \n        else res.push(newEdges.shift() as Edge)\n      }\n      nextEdges = [...res, ...nextEdges, ...newEdges]\n    }\n    \n    let nextEdges: Edge[] = []\n    addVertice(from)\n    while (nextEdges.length > 0) {\n      const bestEdge = nextEdges.pop() as Edge\n      const [vFrom, vTo] = bestEdge.vert1.price !== 0\n        ? [bestEdge.vert1, bestEdge.vert0] : [bestEdge.vert0, bestEdge.vert1]\n      if (vTo.price !== 0) continue\n      let p = bestEdge.pool.calcCurrentPriceWithoutFee(vFrom === bestEdge.vert1);\n      vTo.price = vFrom.price*p\n      vTo.gasPrice = vFrom.gasPrice/p\n      addVertice(vTo)\n    }\n  }\n\n  // Set prices by search in depth\n  setPrices(from: Vertice, price: number, gasPrice: number) {\n    if (from.price !== 0) return\n    from.price = price\n    from.gasPrice = gasPrice\n    const edges = from.edges\n      .map((e): [Edge, number] => [e, parseInt(e.reserve(from).toString())])\n      .sort(([_1, r1], [_2, r2]) => r2 - r1)\n    edges.forEach(([e, _]) => {\n      const v = e.vert0 === from ? e.vert1 : e.vert0;\n      if (v.price !== 0) return;\n      let p = e.pool.calcCurrentPriceWithoutFee(from === e.vert1);\n      this.setPrices(v, price * p, gasPrice / p);\n    });\n  }\n\n  getOrCreateVertice(token: RToken) {\n    let vert = this.tokens.get(token.address)\n    if (vert) return vert\n    vert = new Vertice(token)\n    this.vertices.push(vert)\n    this.tokens.set(token.address, vert)\n    return vert\n  }\n\n  /*exportPath(from: RToken, to: RToken) {\n\n    const fromVert = this.tokens.get(from) as Vertice\n    const toVert = this.tokens.get(to) as Vertice\n    const initValue = (fromVert.bestIncome * fromVert.price) / toVert.price\n\n    const route = new Set<Edge>()\n    for (let v = toVert; v !== fromVert; v = v.getNeibour(v.bestSource) as Vertice) {\n      if (v.bestSource) route.add(v.bestSource)\n    }\n\n    function edgeStyle(e: Edge) {\n      const finish = e.vert1.bestSource === e\n      const start = e.vert0.bestSource === e\n      let label\n      if (e.bestEdgeIncome === -1) label = 'label: \"low_liq\"'\n      if (e.bestEdgeIncome !== 0) label = `label: \"${print((e.bestEdgeIncome / initValue - 1) * 100, 3)}%\"`\n      const edgeValue = route.has(e) ? 'value: 2' : undefined\n      let arrow\n      if (finish && start) arrow = 'arrows: \"from,to\"'\n      if (finish) arrow = 'arrows: \"to\"'\n      if (start) arrow = 'arrows: \"from\"'\n      return ['', label, edgeValue, arrow].filter((a) => a !== undefined).join(', ')\n    }\n\n    function print(n: number, digits: number) {\n      let out\n      if (n === 0) out = '0'\n      else {\n        const n0 = n > 0 ? n : -n\n        const shift = digits - Math.ceil(Math.log(n0) / Math.LN10)\n        if (shift <= 0) out = `${Math.round(n0)}`\n        else {\n          const mult = Math.pow(10, shift)\n          out = `${Math.round(n0 * mult) / mult}`\n        }\n        if (n < 0) out = -out\n      }\n      return out\n    }\n\n    function nodeLabel(v: Vertice) {\n      const value = (v.bestIncome * v.price) / toVert.price\n      const income = `${print(value, 3)}`\n      const total = `${print(v.bestTotal, 3)}`\n      // const income = `${print((value/initValue-1)*100, 3)}%`\n      // const total = `${print((v.bestTotal/initValue-1)*100, 3)}%`\n      const checkLine = v.checkLine === -1 ? undefined : `${v.checkLine}`\n      return [checkLine, income, total].filter((a) => a !== undefined).join(':')\n    }\n\n    const nodes = `var nodes = new vis.DataSet([\n      ${this.vertices.map((t) => `{ id: ${t.token.name}, label: \"${nodeLabel(t)}\"}`).join(',\\n\\t\\t')}\n    ]);\\n`\n    const edges = `var edges = new vis.DataSet([\n      ${this.edges\n        .map((p) => `{ from: ${p.vert0.token.name}, to: ${p.vert1.token.name}${edgeStyle(p)}}`)\n        .join(',\\n\\t\\t')}\n    ]);\\n`\n    const data = `var data = {\n        nodes: nodes,\n        edges: edges,\n    };\\n`\n\n    // TODO: This should be removed, this pacakge will not be installable on a client while this remains.\n    const fs = require(\"fs\");\n    fs.writeFileSync(\n      \"D:/Info/Notes/GraphVisualization/data.js\",\n      nodes + edges + data\n    );\n  }*/\n\n  findBestPathExactIn(\n    from: RToken,\n    to: RToken,\n    amountIn: number,\n    _gasPrice?: number\n  ):\n    | {\n        path: Edge[]\n        output: number\n        gasSpent: number\n        totalOutput: number\n      }\n    | undefined {\n    const start = this.tokens.get(from.address)\n    const finish = this.tokens.get(to.address)\n    if (!start || !finish) return\n\n    const gasPrice = _gasPrice !== undefined ? _gasPrice : finish.gasPrice\n\n    this.edges.forEach((e) => {\n      e.bestEdgeIncome = 0\n      e.spentGasNew = 0\n    });\n    this.vertices.forEach((v) => {\n      v.bestIncome = 0\n      v.gasSpent = 0\n      v.bestTotal = 0\n      v.bestSource = undefined\n      v.checkLine = -1\n    })\n    start.bestIncome = amountIn\n    start.bestTotal = amountIn\n    const processedVert = new Set<Vertice>()\n    const nextVertList = [start] // TODO: Use sorted Set!\n\n    let checkLine = 0\n    for (;;) {\n      let closestVert: Vertice | undefined\n      let closestTotal: number | undefined\n      let closestPosition = 0\n      nextVertList.forEach((v, i) => {\n        if (closestTotal === undefined || v.bestTotal > closestTotal) {\n          closestTotal = v.bestTotal\n          closestVert = v\n          closestPosition = i\n        }\n      })\n\n      if (!closestVert) return\n\n      closestVert.checkLine = checkLine++\n\n      if (closestVert === finish) {\n        const bestPath = []\n        for (let v: Vertice | undefined = finish; v?.bestSource; v = v.getNeibour(v.bestSource)) {\n          bestPath.unshift(v.bestSource)\n        }\n        return {\n          path: bestPath,\n          output: finish.bestIncome,\n          gasSpent: finish.gasSpent,\n          totalOutput: finish.bestTotal,\n        }\n      }\n      nextVertList.splice(closestPosition, 1)\n\n      closestVert.edges.forEach((e) => {\n        const v2 = closestVert === e.vert0 ? e.vert1 : e.vert0\n        if (processedVert.has(v2)) return\n        let newIncome, gas\n        try {\n          const {out, gasSpent} = e.calcOutput(closestVert as Vertice, (closestVert as Vertice).bestIncome)\n          if (!isFinite(out) || !isFinite(gasSpent))   // Math errors protection\n            return\n          newIncome = out\n          gas = gasSpent\n        } catch (e) {\n          // Any arithmetic error or out-of-liquidity\n          return\n        }\n        if (e.checkMinimalLiquidityExceededAfterSwap(closestVert as Vertice, newIncome)) {\n          e.bestEdgeIncome = -1\n          return\n        }\n        const newGasSpent = (closestVert as Vertice).gasSpent + gas\n        const price = v2.price / finish.price\n        const newTotal = newIncome * price - newGasSpent * gasPrice\n\n        console.assert(e.bestEdgeIncome === 0, \"Error 373\");\n        e.bestEdgeIncome = newIncome * price;\n        e.spentGasNew = e.spentGas + gas;\n\n        if (!v2.bestSource) nextVertList.push(v2)\n        if (!v2.bestSource || newTotal > v2.bestTotal) {\n          v2.bestIncome = newIncome\n          v2.gasSpent = newGasSpent\n          v2.bestTotal = newTotal\n          v2.bestSource = e\n        }\n      })\n      processedVert.add(closestVert)\n    }\n  }\n\n  findBestPathExactOut(\n    from: RToken,\n    to: RToken,\n    amountOut: number,\n    _gasPrice?: number\n  ):\n    | {\n        path: Edge[]\n        input: number\n        gasSpent: number\n        totalInput: number\n      }\n    | undefined {\n    const start = this.tokens.get(to.address)\n    const finish = this.tokens.get(from.address)\n    if (!start || !finish) return\n\n    const gasPrice = _gasPrice !== undefined ? _gasPrice : finish.gasPrice\n\n    this.edges.forEach((e) => {\n      e.bestEdgeIncome = 0\n      e.spentGasNew = 0\n    });\n    this.vertices.forEach((v) => {\n      v.bestIncome = 0\n      v.gasSpent = 0\n      v.bestTotal = 0\n      v.bestSource = undefined\n      v.checkLine = -1\n    })\n    start.bestIncome = amountOut\n    start.bestTotal = amountOut\n    const processedVert = new Set<Vertice>()\n    const nextVertList = [start] // TODO: Use sorted Set!\n\n    let checkLine = 0\n    for (;;) {\n      let closestVert: Vertice | undefined\n      let closestTotal: number | undefined\n      let closestPosition = 0\n      nextVertList.forEach((v, i) => {\n        if (closestTotal === undefined || v.bestTotal < closestTotal) {\n          closestTotal = v.bestTotal\n          closestVert = v\n          closestPosition = i\n        }\n      })\n\n      if (!closestVert) return\n\n      closestVert.checkLine = checkLine++\n\n      if (closestVert === finish) {\n        const bestPath = []\n        for (let v: Vertice | undefined = finish; v?.bestSource; v = v.getNeibour(v.bestSource)) {\n          bestPath.push(v.bestSource)\n        }\n        return {\n          path: bestPath,\n          input: finish.bestIncome,\n          gasSpent: finish.gasSpent,\n          totalInput: finish.bestTotal,\n        }\n      }\n      nextVertList.splice(closestPosition, 1)\n\n      closestVert.edges.forEach((e) => {\n        const v2 = closestVert === e.vert0 ? e.vert1 : e.vert0\n        if (processedVert.has(v2)) return\n        let newIncome, gas\n        try {\n          const {inp, gasSpent} = e.calcInput(closestVert as Vertice, (closestVert as Vertice).bestIncome)\n          if (!isFinite(inp) || !isFinite(gasSpent))   // Math errors protection\n            return\n          if (inp < 0) return // No enouph liquidity in the pool\n          newIncome = inp\n          gas = gasSpent\n        } catch (e) {\n          // Any arithmetic error or out-of-liquidity\n          return\n        }\n        const newGasSpent = (closestVert as Vertice).gasSpent + gas\n        const price = v2.price / finish.price\n        const newTotal = newIncome * price + newGasSpent * gasPrice\n\n        console.assert(e.bestEdgeIncome === 0, \"Error 373\");\n        e.bestEdgeIncome = newIncome * price;\n        e.spentGasNew = e.spentGas + gas;\n\n        if (!v2.bestSource) nextVertList.push(v2)\n        if (!v2.bestSource || newTotal < v2.bestTotal) {\n          v2.bestIncome = newIncome\n          v2.gasSpent = newGasSpent\n          v2.bestTotal = newTotal\n          v2.bestSource = e\n        }\n      })\n      processedVert.add(closestVert)\n    }\n  }\n\n  addPath(from: Vertice | undefined, to: Vertice | undefined, path: Edge[]) {\n    let _from = from\n    path.forEach((e) => {\n      if (_from) {\n        e.applySwap(_from)\n        _from = _from.getNeibour(e)\n      } else {\n        console.error('Unexpected 315')\n      }\n    })\n\n    ASSERT(() => {\n      const res = this.vertices.every((v) => {\n        let total = 0\n        let totalModule = 0\n        v.edges.forEach((e) => {\n          if (e.vert0 === v) {\n            if (e.direction) {\n              total -= e.amountInPrevious\n            } else {\n              total += e.amountInPrevious\n            }\n            totalModule += e.amountInPrevious\n          } else {\n            if (e.direction) {\n              total += e.amountOutPrevious\n            } else {\n              total -= e.amountOutPrevious\n            }\n            totalModule += e.amountOutPrevious\n          }\n        })\n        if (v === from) return total <= 0\n        if (v === to) return total >= 0\n        if (totalModule === 0) return total === 0\n        return Math.abs(total / totalModule) < 1e10\n      })\n      return res\n    }, 'Error 290')\n  }\n\n  getPrimaryPriceForPath(from: Vertice, path: Edge[]): number {\n    let p = 1\n    let prevToken = from\n    path.forEach( edge => {\n      const direction = edge.vert0 === prevToken\n      const edgePrice = edge.pool.calcCurrentPriceWithoutFee(direction)\n      p *= edgePrice\n      prevToken = prevToken.getNeibour(edge) as Vertice\n    })\n    return p\n  }\n\n  findBestRouteExactIn(from: RToken, to: RToken, amountIn: number, mode: number | number[]): MultiRoute {\n    let routeValues = []\n    if (Array.isArray(mode)) {\n      const sum = mode.reduce((a, b) => a + b, 0)\n      routeValues = mode.map((e) => e / sum)\n    } else {\n      for (let i = 0; i < mode; ++i) routeValues.push(1 / mode)\n    }\n\n    this.edges.forEach((e) => {\n      e.amountInPrevious = 0\n      e.amountOutPrevious = 0\n      e.direction = true\n    })\n    let output = 0\n    let gasSpentInit = 0\n    //let totalOutput = 0\n    let totalrouted = 0\n    let primaryPrice\n    let step\n    for (step = 0; step < routeValues.length; ++step) {\n      const p = this.findBestPathExactIn(from, to, amountIn * routeValues[step])\n      if (!p) {\n        break\n      } else {\n        output += p.output\n        gasSpentInit += p.gasSpent\n        //totalOutput += p.totalOutput\n        this.addPath(this.tokens.get(from.address), this.tokens.get(to.address), p.path)\n        totalrouted += routeValues[step]\n        if (step === 0) {\n          primaryPrice = this.getPrimaryPriceForPath(this.tokens.get(from.address) as Vertice, p.path)\n        }\n      }\n    }\n    if (step == 0)\n      return {\n        status: RouteStatus.NoWay,\n        fromToken: from,\n        toToken: to,\n        amountIn: 0,\n        amountInBN: BigNumber.from(0),\n        amountOut: 0,\n        amountOutBN: BigNumber.from(0),\n        legs: [],\n        gasSpent: 0,\n        totalAmountOut: 0,\n        totalAmountOutBN: BigNumber.from(0),\n      }\n    let status\n    if (step < routeValues.length) status = RouteStatus.Partial\n    else status = RouteStatus.Success\n\n    const fromVert = this.tokens.get(from.address) as Vertice\n    const toVert = this.tokens.get(to.address) as Vertice\n    const {legs, gasSpent, topologyWasChanged} = this.getRouteLegs(fromVert, toVert)\n    console.assert(gasSpent <= gasSpentInit, 'Internal Error 491')\n\n    if (topologyWasChanged) {\n      output = this.calcLegsAmountOut(legs, amountIn)\n    }\n\n    let swapPrice, priceImpact\n    try {\n      swapPrice = output/amountIn\n      priceImpact = primaryPrice !== undefined? 1- swapPrice/primaryPrice : undefined\n    } catch(e) { /* skip division by 0 errors*/}\n\n    return {\n      status,\n      fromToken: from,\n      toToken: to,\n      primaryPrice,\n      swapPrice,\n      priceImpact,\n      amountIn: amountIn * totalrouted,\n      amountInBN: getBigNumber(amountIn * totalrouted),\n      amountOut: output,\n      amountOutBN: getBigNumber(output),\n      legs,\n      gasSpent,\n      totalAmountOut: output - gasSpent * toVert.gasPrice,\n      totalAmountOutBN: getBigNumber(output - gasSpent * toVert.gasPrice),\n    }\n  }\n\n  findBestRouteExactOut(from: RToken, to: RToken, amountOut: number, mode: number | number[]): MultiRoute {\n    let routeValues = []\n    if (Array.isArray(mode)) {\n      const sum = mode.reduce((a, b) => a + b, 0)\n      routeValues = mode.map((e) => e / sum)\n    } else {\n      for (let i = 0; i < mode; ++i) routeValues.push(1 / mode)\n    }\n\n    this.edges.forEach((e) => {\n      e.amountInPrevious = 0\n      e.amountOutPrevious = 0\n      e.direction = true\n    })\n    let input = 0\n    let gasSpentInit = 0\n    //let totalOutput = 0\n    let totalrouted = 0\n    let primaryPrice\n    let step\n    for (step = 0; step < routeValues.length; ++step) {\n      const p = this.findBestPathExactOut(from, to, amountOut * routeValues[step])\n      if (!p) {\n        break\n      } else {\n        input += p.input\n        gasSpentInit += p.gasSpent\n        //totalOutput += p.totalOutput\n        this.addPath(this.tokens.get(from.address), this.tokens.get(to.address), p.path)\n        totalrouted += routeValues[step]\n        if (step === 0) {\n          primaryPrice = this.getPrimaryPriceForPath(this.tokens.get(from.address) as Vertice, p.path)\n        }\n      }\n    }\n    if (step == 0)\n      return {\n        status: RouteStatus.NoWay,\n        fromToken: from,\n        toToken: to,\n        amountIn: 0,\n        amountInBN: BigNumber.from(0),\n        amountOut: 0,\n        amountOutBN: BigNumber.from(0),\n        legs: [],\n        gasSpent: 0,\n        totalAmountOut: 0,\n        totalAmountOutBN: BigNumber.from(0),\n      }\n    let status\n    if (step < routeValues.length) status = RouteStatus.Partial\n    else status = RouteStatus.Success\n\n    const fromVert = this.tokens.get(from.address) as Vertice\n    const toVert = this.tokens.get(to.address) as Vertice\n    const {legs, gasSpent, topologyWasChanged} = this.getRouteLegs(fromVert, toVert)\n    console.assert(gasSpent <= gasSpentInit, 'Internal Error 491')\n\n    if (topologyWasChanged) {\n      input = this.calcLegsAmountIn(legs, amountOut) ///\n    }\n\n    let swapPrice, priceImpact\n    try {\n      swapPrice = amountOut/input\n      priceImpact = primaryPrice !== undefined? 1- swapPrice/primaryPrice : undefined\n    } catch(e) { /* skip division by 0 errors*/}\n\n    return {\n      status,\n      fromToken: from,\n      toToken: to,\n      primaryPrice,\n      swapPrice,\n      priceImpact,\n      amountIn: input,\n      amountInBN: getBigNumber(input),\n      amountOut: amountOut * totalrouted,\n      amountOutBN: getBigNumber(amountOut * totalrouted),\n      legs,\n      gasSpent,\n      totalAmountOut: amountOut - gasSpent * toVert.gasPrice,\n      totalAmountOutBN: getBigNumber(amountOut - gasSpent * toVert.gasPrice),\n    }\n  }\n\n  getRouteLegs(from: Vertice, to: Vertice): {\n    legs: RouteLeg[],\n    gasSpent: number,\n    topologyWasChanged: boolean\n  } {\n    const {vertices, topologyWasChanged} = this.cleanTopology(from, to)\n    const legs: RouteLeg[] = []\n    let gasSpent = 0\n    vertices.forEach((n) => {\n      const outEdges = n.getOutputEdges().map((e) => {\n        const from = this.edgeFrom(e)\n        return from ? [e, from.vert, from.amount] : [e]\n      })\n\n      let outAmount = outEdges.reduce((a, b) => a + (b[2] as number), 0)\n      if (outAmount <= 0) return\n\n      const total = outAmount\n      outEdges.forEach((e, i) => {\n        const p = e[2] as number\n        const quantity = i + 1 === outEdges.length ? 1 : p / outAmount\n        const edge = e[0] as Edge\n        legs.push({\n          poolAddress: edge.pool.address,\n          poolFee: edge.pool.fee,\n          tokenFrom: n.token,\n          tokenTo: (n.getNeibour(edge) as Vertice).token,\n          assumedAmountIn: edge.direction ? edge.amountInPrevious : edge.amountOutPrevious,\n          assumedAmountOut:  edge.direction ? edge.amountOutPrevious : edge.amountInPrevious,\n          swapPortion: quantity,\n          absolutePortion: p / total,\n        })\n        gasSpent += (e[0] as Edge).pool.swapGasCost\n        outAmount -= p\n      })\n      console.assert(outAmount / total < 1e-12, 'Error 281')\n    })\n    return {legs, gasSpent, topologyWasChanged}\n  }\n\n  edgeFrom(e: Edge): {vert: Vertice, amount: number} | undefined {\n    if (e.amountInPrevious === 0) return undefined\n    return e.direction ? {vert: e.vert0, amount: e.amountInPrevious} : {vert: e.vert1, amount: e.amountOutPrevious}\n  }\n\n  // TODO: make full test coverage!\n  calcLegsAmountOut(legs: RouteLeg[], amountIn: number) {\n    const amounts = new Map<string, number>()\n    amounts.set(legs[0].tokenFrom.address, amountIn)\n    legs.forEach((l) => {\n      const vert = this.tokens.get(l.tokenFrom.address);\n      console.assert(vert !== undefined, \"Internal Error 570\");\n      const edge = (vert as Vertice).edges.find(\n        (e) => e.pool.address === l.poolAddress\n      );\n      console.assert(edge !== undefined, \"Internel Error 569\");\n      const pool = (edge as Edge).pool;\n      const direction = vert === (edge as Edge).vert0;\n\n      const inputTotal = amounts.get(l.tokenFrom.address);\n      console.assert(inputTotal !== undefined, \"Internal Error 564\");\n      const input = (inputTotal as number) * l.swapPortion;\n      amounts.set(l.tokenFrom.address, (inputTotal as number) - input);\n      const output = pool.calcOutByIn(input, direction).out;\n\n      const vertNext = (vert as Vertice).getNeibour(edge) as Vertice;\n      const prevAmount = amounts.get(vertNext.token.address);\n      amounts.set(vertNext.token.address, (prevAmount || 0) + output);\n    });\n    return amounts.get(legs[legs.length-1].tokenTo.address) || 0;\n  }\n\n  // TODO: make full test coverage!\n  calcLegsAmountIn(legs: RouteLeg[], amountOut: number) {\n    const totalOutputAssumed = new Map<string, number>()\n    legs.forEach(l => {\n      const prevValue = totalOutputAssumed.get(l.tokenFrom.address) || 0\n      totalOutputAssumed.set(l.tokenFrom.address, prevValue + l.assumedAmountOut)\n    })\n\n    const amounts = new Map<string, number>()\n    amounts.set(legs[legs.length-1].tokenTo.address, amountOut)\n    for (let i = legs.length - 1; i >= 0; --i) {\n      const l = legs[i]\n      const vert = this.tokens.get(l.tokenTo.address);\n      console.assert(vert !== undefined, \"Internal Error 884\");\n      const edge = (vert as Vertice).edges.find(\n        (e) => e.pool.address === l.poolAddress\n      );\n      console.assert(edge !== undefined, \"Internel Error 888\");\n      const pool = (edge as Edge).pool;\n      const direction = vert === (edge as Edge).vert1;\n\n      const outputTotal = amounts.get(l.tokenTo.address);\n      console.assert(outputTotal !== undefined, \"Internal Error 893\");\n      const totalAssumed = totalOutputAssumed.get(l.tokenFrom.address)\n      console.assert(totalAssumed !== undefined, \"Internal Error 903\");\n      const output = (outputTotal as number) * l.assumedAmountOut / (totalAssumed as number);\n      const input = pool.calcInByOut(output, direction).inp;\n\n      const vertNext = (vert as Vertice).getNeibour(edge) as Vertice;\n      const prevAmount = amounts.get(vertNext.token.address);\n      amounts.set(vertNext.token.address, (prevAmount || 0) + input);\n    };\n    return amounts.get(legs[0].tokenFrom.address) || 0;\n  }\n\n  // removes all cycles if there are any, then removes all dead end could appear after cycle removing\n  // Returns clean result topologically sorted\n  cleanTopology(from: Vertice, to: Vertice): {vertices: Vertice[], topologyWasChanged: boolean} {\n    let topologyWasChanged = false\n    let result = this.topologySort(from, to)\n    if (result.status !== 2) {\n      topologyWasChanged = true\n      console.assert(result.status === 0, 'Internal Error 554')\n      while (result.status === 0) {\n        this.removeWeakestEdge(result.vertices)\n        result = this.topologySort(from, to)\n      }\n      if (result.status === 3) {\n        this.removeDeadEnds(result.vertices)\n        result = this.topologySort(from, to)\n      }\n      console.assert(result.status === 2, 'Internal Error 563')\n      if (result.status !== 2) return {vertices: [], topologyWasChanged}\n    }\n    return {vertices: result.vertices, topologyWasChanged}\n  }\n\n  removeDeadEnds(verts: Vertice[]) {\n    verts.forEach((v) => {\n      v.getInputEdges().forEach((e) => {\n        e.canBeUsed = false\n      })\n    })\n  }\n\n  removeWeakestEdge(verts: Vertice[]) {\n    let minVert: Vertice, minVertNext: Vertice\n    let minOutput = Number.MAX_VALUE\n    verts.forEach((v1, i) => {\n      const v2 = i === 0 ? verts[verts.length - 1] : verts[i - 1]\n      let out = 0\n      v1.getOutputEdges().forEach((e) => {\n        if (v1.getNeibour(e) !== v2) return\n        out += e.direction ? e.amountOutPrevious : e.amountInPrevious\n      })\n      if (out < minOutput) {\n        minVert = v1\n        minVertNext = v2\n        minOutput = out\n      }\n    })\n    // @ts-ignore\n    minVert.getOutputEdges().forEach((e) => {\n      if (minVert.getNeibour(e) !== minVertNext) return\n      e.canBeUsed = false\n    })\n  }\n\n  // topological sort\n  // if there is a cycle - returns [0, <List of envolved vertices in the cycle>]\n  // if there are no cycles but deadends- returns [3, <List of all envolved deadend vertices>]\n  // if there are no cycles or deadends- returns [2, <List of all envolved vertices topologically sorted>]\n  topologySort(from: Vertice, to: Vertice): {status: number, vertices: Vertice[]} {\n    // undefined or 0 - not processed, 1 - in process, 2 - finished, 3 - dedend\n    const vertState = new Map<Vertice, number>()\n    const vertsFinished: Vertice[] = []\n    const foundCycle: Vertice[] = []\n    const foundDeadEndVerts: Vertice[] = []\n\n    // 0 - cycle was found and created, return\n    // 1 - during cycle creating\n    // 2 - vertex is processed ok\n    // 3 - dead end vertex\n    function topSortRecursive(current: Vertice): number {\n      const state = vertState.get(current)\n      if (state === 2 || state === 3) return state\n      if (state === 1) {\n        console.assert(foundCycle.length == 0, 'Internal Error 566')\n        foundCycle.push(current)\n        return 1\n      }\n      vertState.set(current, 1)\n\n      let successors2Exist = false\n      const outEdges = current.getOutputEdges()\n      for (let i = 0; i < outEdges.length; ++i) {\n        const e = outEdges[i]\n        const res = topSortRecursive(current.getNeibour(e) as Vertice)\n        if (res === 0) return 0\n        if (res === 1) {\n          if (foundCycle[0] === current) return 0\n          else {\n            foundCycle.push(current)\n            return 1\n          }\n        }\n        if (res === 2) successors2Exist = true // Ok successors\n      }\n      if (successors2Exist) {\n        console.assert(current !== to, 'Internal Error 589')\n        vertsFinished.push(current)\n        vertState.set(current, 2)\n        return 2\n      } else {\n        if (current !== to) {\n          foundDeadEndVerts.push(current)\n          vertState.set(current, 3)\n          return 3\n        }\n        vertsFinished.push(current)\n        vertState.set(current, 2)\n        return 2\n      }\n    }\n\n    const res = topSortRecursive(from)\n    if (res === 0) return {status: 0, vertices: foundCycle}\n    if (foundDeadEndVerts.length) return {status: 3, vertices: foundDeadEndVerts}\n    ASSERT(() => {\n      if (vertsFinished[0] !== to) return false\n      if (vertsFinished[vertsFinished.length - 1] !== from) return false\n      return true\n    }, 'Internal Error 614')\n    if (res === 2) return {status: 2, vertices: vertsFinished.reverse()}\n    console.assert(true, 'Internal Error 612')\n    return {status: 1, vertices: []}\n  }\n}","import { BigNumber } from '@ethersproject/bignumber'\nimport { getBigNumber, revertPositive } from './Utils'\n\nexport const TYPICAL_SWAP_GAS_COST = 40_000\nexport const TYPICAL_MINIMAL_LIQUIDITY = 1000\n\nexport interface RToken {\n  name: string\n  address: string\n}\n\nexport abstract class RPool {\n  readonly address: string\n  readonly token0: RToken\n  readonly token1: RToken\n  readonly fee: number\n  reserve0: BigNumber\n  reserve1: BigNumber\n  readonly minLiquidity: number\n  readonly swapGasCost: number\n\n  constructor(\n    address: string,\n    token0: RToken,\n    token1: RToken,\n    fee: number,\n    reserve0: BigNumber,\n    reserve1: BigNumber,\n    minLiquidity = TYPICAL_MINIMAL_LIQUIDITY,\n    swapGasCost = TYPICAL_SWAP_GAS_COST\n  ) {\n    this.address = address\n    ;(this.token0 = token0), (this.token1 = token1)\n    this.fee = fee\n    this.minLiquidity = minLiquidity\n    this.swapGasCost = swapGasCost\n    this.reserve0 = reserve0\n    this.reserve1 = reserve1\n  }\n\n  updateReserves(res0: BigNumber, res1: BigNumber) {\n    this.reserve0 = res0\n    this.reserve1 = res1\n  }\n\n  // Returns [<output amount>, <gas consumption estimation>]\n  abstract calcOutByIn(amountIn: number, direction: boolean): {out: number, gasSpent: number}\n  abstract calcInByOut(amountOut: number, direction: boolean): {inp: number, gasSpent: number}\n  abstract calcCurrentPriceWithoutFee(direction: boolean): number\n  // abstract calcPrice(amountIn: number, direction: boolean, takeFeeIntoAccount: boolean): number;\n  // abstract calcInputByPrice(price: number, direction: boolean, takeFeeIntoAccount: boolean, hint: number): number;\n}\n\nexport class ConstantProductRPool extends RPool {\n  reserve0Number: number\n  reserve1Number: number\n\n  constructor(address: string, token0: RToken, token1: RToken, fee: number, reserve0: BigNumber, reserve1: BigNumber) {\n    super(address, token0, token1, fee, reserve0, reserve1)\n    this.reserve0Number = parseInt(reserve0.toString())\n    this.reserve1Number = parseInt(reserve1.toString())\n  }\n\n  updateReserves(res0: BigNumber, res1: BigNumber) {\n    this.reserve0 = res0\n    this.reserve0Number = parseInt(res0.toString())\n    this.reserve1 = res1\n    this.reserve1Number = parseInt(res1.toString())\n  }\n\n  calcOutByIn(amountIn: number, direction: boolean): {out: number, gasSpent: number} {\n    const x = direction ? this.reserve0Number : this.reserve1Number\n    const y = direction ? this.reserve1Number : this.reserve0Number\n    return {out: (y * amountIn) / (x / (1 - this.fee) + amountIn), gasSpent: this.swapGasCost}\n  }\n\n  calcInByOut(amountOut: number, direction: boolean): {inp: number, gasSpent: number} {\n    const x = direction ? this.reserve0Number : this.reserve1Number\n    const y = direction ? this.reserve1Number : this.reserve0Number\n    let input = (x * amountOut) / (1 - this.fee) / (y - amountOut)\n    //if (input < 1) input = 1\n    return {inp: input, gasSpent: this.swapGasCost}\n  }\n\n  calcCurrentPriceWithoutFee(direction: boolean): number {\n    return this.calcPrice(0, direction, false)\n  }\n\n  calcPrice(amountIn: number, direction: boolean, takeFeeIntoAccount: boolean): number {\n    const x = direction ? this.reserve0Number : this.reserve1Number\n    const y = direction ? this.reserve1Number : this.reserve0Number\n    const oneMinusFee = takeFeeIntoAccount ? 1 - this.fee : 1\n    const xf = x / oneMinusFee\n    return (y * xf) / (xf + amountIn) / (xf + amountIn)\n  }\n\n  calcInputByPrice(price: number, direction: boolean, takeFeeIntoAccount: boolean): number {\n    const x = direction ? this.reserve0Number : this.reserve1Number\n    const y = direction ? this.reserve1Number : this.reserve0Number\n    const oneMinusFee = takeFeeIntoAccount ? 1 - this.fee : 1\n    const xf = x / oneMinusFee\n    return Math.sqrt(y * xf * price) - xf // TODO: or y*xf/price ???\n  }\n\n  getLiquidity() {\n    return Math.sqrt(this.reserve0Number * this.reserve1Number)\n  }\n}\n\nexport class HybridRPool extends RPool {\n  readonly A: number\n  readonly A_PRECISION = 100\n  D: BigNumber // set it to 0 if reserves are changed !!\n\n  constructor(\n    address: string,\n    token0: RToken,\n    token1: RToken,\n    fee: number,\n    A: number,\n    reserve0: BigNumber,\n    reserve1: BigNumber\n  ) {\n    super(address, token0, token1, fee, reserve0, reserve1)\n    this.A = A\n    this.D = BigNumber.from(0)\n  }\n\n  updateReserves(res0: BigNumber, res1: BigNumber) {\n    this.D = BigNumber.from(0)\n    this.reserve0 = res0\n    this.reserve1 = res1\n  }\n\n  computeLiquidity(): BigNumber {\n    if (!this.D.eq(0)) return this.D // already calculated\n\n    const r0 = this.reserve0\n    const r1 = this.reserve1\n\n    if (r0.isZero() && r1.isZero()) return BigNumber.from(0)\n\n    const s = r0.add(r1)\n    const nA = BigNumber.from(this.A * 2)\n    let prevD\n    let D = s\n    for (let i = 0; i < 256; i++) {\n      const dP = D.mul(D).div(r0).mul(D).div(r1).div(4)\n      prevD = D\n      D = nA\n        .mul(s)\n        .div(this.A_PRECISION)\n        .add(dP.mul(2))\n        .mul(D)\n        .div(nA.div(this.A_PRECISION).sub(1).mul(D).add(dP.mul(3)))\n      if (D.sub(prevD).abs().lte(1)) {\n        break\n      }\n    }\n    this.D = D\n    return D\n  }\n\n  computeY(x: BigNumber): BigNumber {\n    const D = this.computeLiquidity()\n\n    const nA = this.A * 2\n\n    let c = D.mul(D)\n      .div(x.mul(2))\n      .mul(D)\n      .div((nA * 2) / this.A_PRECISION)\n    let b = D.mul(this.A_PRECISION).div(nA).add(x)\n\n    let yPrev\n    let y = D\n    for (let i = 0; i < 256; i++) {\n      yPrev = y\n\n      y = y.mul(y).add(c).div(y.mul(2).add(b).sub(D))\n      if (y.sub(yPrev).abs().lte(1)) {\n        break\n      }\n    }\n    return y\n  }\n\n  calcOutByIn(amountIn: number, direction: boolean): {out: number, gasSpent: number} {\n    const xBN = direction ? this.reserve0 : this.reserve1\n    const yBN = direction ? this.reserve1 : this.reserve0\n    const xNewBN = xBN.add(getBigNumber(amountIn * (1 - this.fee)))\n    const yNewBN = this.computeY(xNewBN)\n    const dy = parseInt(yBN.sub(yNewBN).toString())\n\n    return {out: dy, gasSpent: this.swapGasCost}\n  }\n\n  calcInByOut(amountOut: number, direction: boolean): {inp: number, gasSpent: number} {\n    const xBN = direction ? this.reserve0 : this.reserve1\n    const yBN = direction ? this.reserve1 : this.reserve0\n    let yNewBN = yBN.sub(getBigNumber(amountOut))\n    if (yNewBN.lt(1))\n      // lack of precision\n      yNewBN = BigNumber.from(1)\n\n    const xNewBN = this.computeY(yNewBN)\n    let input = Math.round(parseInt(xNewBN.sub(xBN).toString()) / (1 - this.fee))\n\n    //if (input < 1) input = 1\n    return {inp: input, gasSpent: this.swapGasCost}\n  }\n\n  calcCurrentPriceWithoutFee(direction: boolean): number {\n    return this.calcPrice(0, direction, false)\n  }\n\n  calcPrice(amountIn: number, direction: boolean, takeFeeIntoAccount: boolean): number {\n    const xBN = direction ? this.reserve0 : this.reserve1\n    const x = parseInt(xBN.toString())\n    const oneMinusFee = takeFeeIntoAccount ? 1 - this.fee : 1\n    const D = parseInt(this.computeLiquidity().toString())\n    const A = this.A / this.A_PRECISION\n    const xI = x + amountIn\n    const b = 4 * A * xI + D - 4 * A * D\n    const ac4 = (D * D * D) / xI\n    const Ds = Math.sqrt(b * b + 4 * A * ac4)\n    const res = (0.5 - (2 * b - ac4 / xI) / Ds / 4) * oneMinusFee\n    return res\n  }\n\n  calcInputByPrice(price: number, direction: boolean, takeFeeIntoAccount: boolean, hint = 1): number {\n    // TODO:  (x:number) => this.calcPrice(x, !direction, takeFeeIntoAccount)  ???\n    return revertPositive((x: number) => 1 / this.calcPrice(x, direction, takeFeeIntoAccount), price, hint)\n  }\n}\n","import { BigNumber } from \"@ethersproject/bignumber\";\nimport { RPool, RToken, TYPICAL_MINIMAL_LIQUIDITY, TYPICAL_SWAP_GAS_COST } from \"./PrimaryPools\";\n\nexport const CL_MIN_TICK = -887272\nexport const CL_MAX_TICK = -CL_MIN_TICK - 1\n\nexport interface CLTick {\n  index: number\n  DLiquidity: number\n}\n\nexport class CLRPool extends RPool {\n  tickSpacing: number\n  liquidity: number\n  sqrtPrice: number\n  nearestTick: number\n  ticks: CLTick[]\n\n  constructor(      \n    address: string,\n    token0: RToken,\n    token1: RToken,\n    fee: number,\n    tickSpacing: number,\n    reserve0: BigNumber,\n    reserve1: BigNumber,\n    liquidity: number,\n    sqrtPrice: number,\n    nearestTick: number,\n    ticks: CLTick[]\n  ) {\n    super(      \n      address,\n      token0,\n      token1,\n      fee,\n      reserve0,\n      reserve1,\n      TYPICAL_MINIMAL_LIQUIDITY,\n      TYPICAL_SWAP_GAS_COST,\n    )\n    this.tickSpacing = tickSpacing\n    this.liquidity = liquidity\n    this.sqrtPrice = sqrtPrice\n    this.nearestTick = nearestTick\n    this.ticks = ticks\n    if (this.ticks.length === 0) {\n      this.ticks.push({ index: CL_MIN_TICK, DLiquidity: 0 })\n      this.ticks.push({ index: CL_MAX_TICK, DLiquidity: 0 })\n    }\n    if (this.ticks[0].index > CL_MIN_TICK) this.ticks.unshift({ index: CL_MIN_TICK, DLiquidity: 0 })\n    if (this.ticks[this.ticks.length - 1].index < CL_MAX_TICK) this.ticks.push({ index: CL_MAX_TICK, DLiquidity: 0 })\n  }\n\n  calcOutByIn(amountIn: number, direction: boolean): {out: number, gasSpent: number} {\n    let nextTickToCross = direction ? this.nearestTick : this.nearestTick + 1\n    let currentPrice = this.sqrtPrice\n    let currentLiquidity = this.liquidity\n    let outAmount = 0\n    let input = amountIn\n  \n    while (input > 0) {\n      if (nextTickToCross < 0 || nextTickToCross >= this.ticks.length)\n        return {out: outAmount, gasSpent: this.swapGasCost}\n  \n      const nextTickPrice = Math.sqrt(Math.pow(1.0001, this.ticks[nextTickToCross].index))\n      // console.log('L, P, tick, nextP', currentLiquidity,\n      //     currentPrice, this.ticks[nextTickToCross].index, nextTickPrice);\n      let output = 0\n  \n      if (direction) {\n        const maxDx = (currentLiquidity * (currentPrice - nextTickPrice)) / currentPrice / nextTickPrice\n        //console.log('input, maxDx', input, maxDx);\n  \n        if (input <= maxDx) {\n          output = (currentLiquidity * currentPrice * input) / (input + currentLiquidity / currentPrice)\n          input = 0\n        } else {\n          output = currentLiquidity * (currentPrice - nextTickPrice)\n          currentPrice = nextTickPrice\n          input -= maxDx\n          if ( (this.ticks[nextTickToCross].index/this.tickSpacing) % 2 === 0) {\n            currentLiquidity -= this.ticks[nextTickToCross].DLiquidity\n          } else {\n            currentLiquidity += this.ticks[nextTickToCross].DLiquidity\n          }\n          nextTickToCross--\n        }\n      } else {\n        const maxDy = currentLiquidity * (nextTickPrice - currentPrice)\n        //console.log('input, maxDy', input, maxDy);\n        if (input <= maxDy) {\n          output = input / currentPrice / (currentPrice + input / currentLiquidity)\n          input = 0\n        } else {\n          output = (currentLiquidity * (nextTickPrice - currentPrice)) / currentPrice / nextTickPrice\n          currentPrice = nextTickPrice\n          input -= maxDy\n          if ( (this.ticks[nextTickToCross].index/this.tickSpacing) % 2 === 0) {\n            currentLiquidity += this.ticks[nextTickToCross].DLiquidity\n          } else {\n            currentLiquidity -= this.ticks[nextTickToCross].DLiquidity\n          }\n          nextTickToCross++\n        }\n      }\n  \n      outAmount += output * (1 - this.fee)\n      //console.log('out', outAmount);\n    }\n  \n    return {out: outAmount, gasSpent: this.swapGasCost}  // TODO: more accurate gas prediction \n  }\n\n  calcInByOut(amountOut: number, direction: boolean): {inp: number, gasSpent: number} {  \n    let nextTickToCross = direction ? this.nearestTick : this.nearestTick + 1\n    let currentPrice = this.sqrtPrice\n    let currentLiquidity = this.liquidity\n    let input = 0\n    let outBeforeFee = amountOut/(1-this.fee)    \n\n    while (outBeforeFee > 0) {\n      if (nextTickToCross < 0 || nextTickToCross >= this.ticks.length)\n        return {inp: input, gasSpent: this.swapGasCost}\n  \n      const nextTickPrice = Math.sqrt(Math.pow(1.0001, this.ticks[nextTickToCross].index))\n      // console.log('L, P, tick, nextP', currentLiquidity,\n      //     currentPrice, this.ticks[nextTickToCross].index, nextTickPrice);\n  \n      if (direction) {\n        const maxDy = currentLiquidity * (currentPrice - nextTickPrice)\n        //console.log('input, maxDy', input, maxDy);\n        if (outBeforeFee <= maxDy) {\n          input += outBeforeFee / currentPrice / (currentPrice - outBeforeFee / currentLiquidity)\n          outBeforeFee = 0\n        } else {\n          input += (currentLiquidity * (currentPrice - nextTickPrice)) / currentPrice / nextTickPrice\n          currentPrice = nextTickPrice\n          outBeforeFee -= maxDy\n          if ( (this.ticks[nextTickToCross].index/this.tickSpacing) % 2 === 0) {\n            currentLiquidity -= this.ticks[nextTickToCross].DLiquidity\n          } else {\n            currentLiquidity += this.ticks[nextTickToCross].DLiquidity\n          }\n          nextTickToCross--\n        }\n      } else {\n        const maxDx = (currentLiquidity * (nextTickPrice - currentPrice)) / currentPrice / nextTickPrice\n        //console.log('outBeforeFee, maxDx', outBeforeFee, maxDx);\n  \n        if (outBeforeFee <= maxDx) {\n          input += (currentLiquidity * currentPrice * outBeforeFee) / (currentLiquidity / currentPrice - outBeforeFee)\n          outBeforeFee = 0\n        } else {\n          input += currentLiquidity * (nextTickPrice - currentPrice)\n          currentPrice = nextTickPrice\n          outBeforeFee -= maxDx\n          if ( (this.ticks[nextTickToCross].index/this.tickSpacing) % 2 === 0) {\n            currentLiquidity += this.ticks[nextTickToCross].DLiquidity\n          } else {\n            currentLiquidity -= this.ticks[nextTickToCross].DLiquidity\n          }\n          nextTickToCross++\n        }\n      }\n    }\n  \n    return {inp: input, gasSpent: this.swapGasCost}\n  }\n  \n  calcCurrentPriceWithoutFee(direction: boolean): number {\n    const p = this.sqrtPrice*this.sqrtPrice\n    return direction ? p : 1/p\n  }\n}\n","import { BigNumber } from '@ethersproject/bignumber'\n\ninterface RToken {\n  name: string\n  address: string\n}\n\nexport enum PoolType {\n  ConstantProduct = 'ConstantProduct',\n  Weighted = 'Weighted',\n  Hybrid = 'Hybrid',\n  ConcentratedLiquidity = 'ConcentratedLiquidity',\n}\n\nexport interface PoolInfo {\n  address: string\n  token0: RToken\n  token1: RToken\n  type: PoolType\n  reserve0: BigNumber\n  reserve1: BigNumber\n  fee: number\n  minLiquidity: number\n  swapGasCost: number\n}\n\ntype Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>\ntype PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>\ntype PoolInfoWithDefaults = PartialBy<PoolInfo, 'minLiquidity' | 'swapGasCost'>\n\nexport class Pool {\n  address: string\n  token0: RToken\n  token1: RToken\n  type: PoolType\n  reserve0: BigNumber\n  reserve1: BigNumber\n  fee: number\n  minLiquidity: number\n  swapGasCost: number\n\n  constructor(_info: PoolInfoWithDefaults) {\n    const info = {\n      minLiquidity: 1000,\n      swapGasCost: 40_000,\n      ..._info,\n    }\n    this.address = info.address\n    this.token0 = info.token0\n    this.token1 = info.token1\n    this.type = info.type\n    this.reserve0 = info.reserve0\n    this.reserve1 = info.reserve1\n    this.fee = info.fee\n    this.minLiquidity = info.minLiquidity\n    this.swapGasCost = info.swapGasCost\n  }\n}\n\ntype PoolInfoNoType = Omit<PoolInfoWithDefaults, 'type'>\n\nexport class RConstantProductPool extends Pool {\n  constructor(info: PoolInfoNoType) {\n    super({\n      type: PoolType.ConstantProduct,\n      ...info,\n    })\n  }\n}\n\ntype HybridPoolInfo = PoolInfoNoType & { A: number }\n\nexport class RHybridPool extends Pool {\n  A: number\n  constructor(info: HybridPoolInfo) {\n    super({\n      type: PoolType.Hybrid,\n      ...info,\n    })\n    this.A = info.A\n  }\n}\n\ntype WeightedPoolInfo = PoolInfoNoType & { weight0: number; weight1: number }\n\nexport class RWeightedPool extends Pool {\n  weight0: number\n  weight1: number\n  constructor(info: WeightedPoolInfo) {\n    super({\n      type: PoolType.Weighted,\n      ...info,\n    })\n    this.weight0 = info.weight0\n    this.weight1 = info.weight1\n  }\n}\n\ninterface CLTick {\n  index: number\n  DLiquidity: number\n}\n\ninterface CLSpecific {\n  liquidity: number\n  sqrtPrice: number\n  nearestTick: number\n  ticks: CLTick[]\n}\n\ntype CLPoolInfo = Omit<PoolInfoNoType, 'reserve0' | 'reserve1'> & CLSpecific\n\nexport class RConcentratedLiquidityPool extends Pool {\n  liquidity: number\n  sqrtPrice: number\n  nearestTick: number\n  ticks: CLTick[]\n  constructor(info: CLPoolInfo) {\n    super({\n      type: PoolType.ConcentratedLiquidity,\n      reserve0: BigNumber.from(0),\n      reserve1: BigNumber.from(0),\n      ...info,\n    })\n    this.liquidity = info.liquidity\n    this.sqrtPrice = info.sqrtPrice\n    this.nearestTick = info.nearestTick\n    this.ticks = info.ticks\n  }\n}\n\n","import { BigNumber } from \"@ethersproject/bignumber\";\nimport { MultiRoute, Graph, RouteStatus } from \"./Graph\";\nimport { RPool, RToken } from \"./PrimaryPools\";  \n\n// Assumes route is a single path\nfunction calcPriceImactWithoutFee(route: MultiRoute) {\n  if (route.primaryPrice === undefined || route.swapPrice === undefined) {\n    return undefined\n  } else {\n    let oneMinusCombinedFee = 1\n    route.legs.forEach(l => oneMinusCombinedFee *= (1-l.poolFee))\n    //const combinedFee = 1-oneMinusCombinedFee\n    return Math.max(0, 1-route.swapPrice/route.primaryPrice/oneMinusCombinedFee)\n  }\n}\n\nconst defaultFlowNumber = 12\nconst maxFlowNumber = 100\nfunction calcBestFlowNumber(bestSingleRoute: MultiRoute, amountIn: number, gasPriceIn?: number): number {\n  const priceImpact = calcPriceImactWithoutFee(bestSingleRoute)\n  if (!priceImpact) return defaultFlowNumber\n\n  const bestFlowAmount = Math.sqrt(bestSingleRoute.gasSpent*(gasPriceIn || 0)*amountIn/priceImpact)\n  const bestFlowNumber = Math.round(amountIn/bestFlowAmount)\n  if (!isFinite(bestFlowNumber)) return defaultFlowNumber\n\n  const realFlowNumber = Math.max(1, Math.min(bestFlowNumber, maxFlowNumber))\n  return realFlowNumber\n}\n\nfunction getBetterRouteExactIn(route1: MultiRoute, route2: MultiRoute): MultiRoute {\n  if (route1.status == RouteStatus.NoWay) return route2\n  if (route2.status == RouteStatus.NoWay) return route1\n  if (route1.status == RouteStatus.Partial && route2.status == RouteStatus.Success) return route2\n  if (route2.status == RouteStatus.Partial && route1.status == RouteStatus.Success) return route1\n  return route1.totalAmountOut > route2.totalAmountOut ? route1 : route2\n}\n\nexport function findMultiRouteExactIn(\n  from: RToken,\n  to: RToken,\n  amountIn: BigNumber | number,\n  pools: RPool[],\n  baseToken: RToken,\n  gasPrice: number,\n  flows?: number | number[]\n): MultiRoute {\n  if (amountIn instanceof BigNumber) {\n    amountIn = parseInt(amountIn.toString())\n  }\n\n  const g = new Graph(pools, baseToken, gasPrice)\n  const fromV = g.tokens.get(from.address)\n  if (fromV?.price === 0) {\n    g.setPricesStable(fromV, 1, 0)\n  }\n\n  if (flows !== undefined) return g.findBestRouteExactIn(from, to, amountIn, flows)\n\n  const outSingle = g.findBestRouteExactIn(from, to, amountIn, 1)\n  // Possible optimization of timing\n  // if (g.findBestPathExactIn(from, to, amountIn/100 + 10_000, 0)?.gasSpent === 0) return outSingle\n  g.cleanTmpData()\n\n  const bestFlowNumber = calcBestFlowNumber(outSingle, amountIn, fromV?.gasPrice)\n  if (bestFlowNumber === 1) return outSingle\n\n  const outMulti = g.findBestRouteExactIn(from, to, amountIn, bestFlowNumber)\n  return getBetterRouteExactIn(outSingle, outMulti)\n}\n\nfunction getBetterRouteExactOut(route1: MultiRoute, route2: MultiRoute, gasPrice: number): MultiRoute {\n  if (route1.status == RouteStatus.NoWay) return route2\n  if (route2.status == RouteStatus.NoWay) return route1\n  if (route1.status == RouteStatus.Partial && route2.status == RouteStatus.Success) return route2\n  if (route2.status == RouteStatus.Partial && route1.status == RouteStatus.Success) return route1\n  const totalAmountIn1 = route1.amountIn + route1.gasSpent*gasPrice\n  const totalAmountIn2 = route2.amountIn + route2.gasSpent*gasPrice\n  return totalAmountIn1 < totalAmountIn2 ? route1 : route2\n}\n\nexport function findMultiRouteExactOut(\n  from: RToken,\n  to: RToken,\n  amountOut: BigNumber | number,\n  pools: RPool[],\n  baseToken: RToken,\n  gasPrice: number,\n  flows?: number | number[]\n): MultiRoute {\n  if (amountOut instanceof BigNumber) {\n    amountOut = parseInt(amountOut.toString())\n  }\n\n  const g = new Graph(pools, baseToken, gasPrice)\n  const fromV = g.tokens.get(from.address)\n  if (fromV?.price === 0) {\n    g.setPricesStable(fromV, 1, 0)\n  }\n\n  if (flows !== undefined) return g.findBestRouteExactOut(from, to, amountOut, flows)\n\n  const inSingle = g.findBestRouteExactOut(from, to, amountOut, 1)\n  // Possible optimization of timing\n  // if (g.findBestPathExactOut(from, to, amountOut/100 + 10_000, 0)?.gasSpent === 0) return inSingle\n  g.cleanTmpData()\n\n  const bestFlowNumber = calcBestFlowNumber(inSingle, inSingle.amountIn, fromV?.gasPrice)\n  if (bestFlowNumber === 1) return inSingle\n\n  const inMulti = g.findBestRouteExactOut(from, to, amountOut, bestFlowNumber)\n  return getBetterRouteExactOut(inSingle, inMulti, gasPrice)\n}\n\nexport function findSingleRouteExactIn(\n  from: RToken,\n  to: RToken,\n  amountIn: BigNumber | number,\n  pools: RPool[],\n  baseToken: RToken,\n  gasPrice: number\n): MultiRoute {\n  const g = new Graph(pools, baseToken, gasPrice)\n  const fromV = g.tokens.get(from.address)\n  if (fromV?.price === 0) {\n    g.setPricesStable(fromV, 1, 0)\n  }\n\n  if (amountIn instanceof BigNumber) {\n    amountIn = parseInt(amountIn.toString())\n  }\n\n  const out = g.findBestRouteExactIn(from, to, amountIn, 1)\n  return out\n}\n\nexport function findSingleRouteExactOut(\n  from: RToken,\n  to: RToken,\n  amountOut: BigNumber | number,\n  pools: RPool[],\n  baseToken: RToken,\n  gasPrice: number\n): MultiRoute {\n  const g = new Graph(pools, baseToken, gasPrice)\n  const fromV = g.tokens.get(from.address)\n  if (fromV?.price === 0) {\n    g.setPricesStable(fromV, 1, 0)\n  }\n\n  if (amountOut instanceof BigNumber) {\n    amountOut = parseInt(amountOut.toString())\n  }\n\n  const out = g.findBestRouteExactOut(from, to, amountOut, 1)\n  return out\n}\n\nexport function calcTokenPrices(pools: RPool[], baseToken: RToken): Map<RToken, number> {\n  const g = new Graph(pools, baseToken, 0)\n  const res = new Map<RToken, number>()\n  g.vertices.forEach(v => res.set(v.token, v.price))\n  return res\n}","import {\n  Pool,\n  PoolType,\n  RHybridPool,\n  RWeightedPool,\n} from './MultiRouterTypes'\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { getBigNumber, revertPositive } from \"../Utils\";\n\nconst A_PRECISION = 100\n\nconst DCacheBN = new Map<Pool, BigNumber>()\nexport function HybridComputeLiquidity(pool: RHybridPool): BigNumber {\n  const res = DCacheBN.get(pool)\n  if (res !== undefined) return res\n\n  const r0 = pool.reserve0\n  const r1 = pool.reserve1\n\n  if (r0.isZero() && r1.isZero()) {\n    DCacheBN.set(pool, BigNumber.from(0))\n    return BigNumber.from(0)\n  }\n  const s = r0.add(r1)\n\n  const nA = BigNumber.from(pool.A * 2)\n\n  let prevD\n\n  let D = s\n  for (let i = 0; i < 256; i++) {\n    const dP = D.mul(D).div(r0).mul(D).div(r1).div(4)\n    prevD = D\n    D = nA\n      .mul(s)\n      .div(A_PRECISION)\n      .add(dP.mul(2))\n      .mul(D)\n      .div(nA.div(A_PRECISION).sub(1).mul(D).add(dP.mul(3)))\n    if (D.sub(prevD).abs().lte(1)) {\n      break\n    }\n  }\n  DCacheBN.set(pool, D)\n  return D\n}\n\nexport function HybridgetY(pool: RHybridPool, x: BigNumber): BigNumber {\n  const D = HybridComputeLiquidity(pool)\n\n  const nA = pool.A * 2\n\n  let c = D.mul(D)\n    .div(x.mul(2))\n    .mul(D)\n    .div((nA * 2) / A_PRECISION)\n  let b = D.mul(A_PRECISION).div(nA).add(x)\n\n  let yPrev\n  let y = D\n  for (let i = 0; i < 256; i++) {\n    yPrev = y\n\n    y = y.mul(y).add(c).div(y.mul(2).add(b).sub(D))\n    if (y.sub(yPrev).abs().lte(1)) {\n      break\n    }\n  }\n  return y\n}\n\nexport function calcOutByIn(pool: Pool, amountIn: number, direction = true): number {\n  const xBN = direction ? pool.reserve0 : pool.reserve1\n  const yBN = direction ? pool.reserve1 : pool.reserve0\n  switch (pool.type) {\n    case PoolType.ConstantProduct: {\n      const x = parseInt(xBN.toString())\n      const y = parseInt(yBN.toString())\n      return (y * amountIn) / (x / (1 - pool.fee) + amountIn)\n    }\n    case PoolType.Weighted: {\n      const x = parseInt(xBN.toString())\n      const y = parseInt(yBN.toString())\n      const wPool = pool as RWeightedPool\n      const weightRatio = direction ? wPool.weight0 / wPool.weight1 : wPool.weight1 / wPool.weight0\n      const actualIn = amountIn * (1 - pool.fee)\n      const out = y * (1 - Math.pow(x / (x + actualIn), weightRatio))\n      return out\n    }\n    case PoolType.Hybrid: {\n      // const xNew = x + amountIn*(1-pool.fee);\n      // const yNew = HybridgetY(pool, xNew);\n      // const dy = y - yNew;\n\n      const xNewBN = xBN.add(getBigNumber(amountIn * (1 - pool.fee)))\n      const yNewBN = HybridgetY(pool as RHybridPool, xNewBN)\n      const dy = parseInt(yBN.sub(yNewBN).toString())\n\n      return dy\n    }\n  }\n  return -1\n}\n\nexport class OutOfLiquidity extends Error {}\n\n\nexport function calcInByOut(pool: Pool, amountOut: number, direction: boolean): number {\n  let input = 0\n  const xBN = direction ? pool.reserve0 : pool.reserve1\n  const yBN = direction ? pool.reserve1 : pool.reserve0\n  switch (pool.type) {\n    case PoolType.ConstantProduct: {\n      const x = parseInt(xBN.toString())\n      const y = parseInt(yBN.toString())\n      input = (x * amountOut) / (1 - pool.fee) / (y - amountOut)\n      break\n    }\n    case PoolType.Weighted: {\n      const x = parseInt(xBN.toString())\n      const y = parseInt(yBN.toString())\n      const wPool = pool as RWeightedPool\n      const weightRatio = direction ? wPool.weight0 / wPool.weight1 : wPool.weight1 / wPool.weight0\n      input = x * (1 - pool.fee) * (Math.pow(1 - amountOut / y, -weightRatio) - 1)\n      break\n    }\n    case PoolType.Hybrid: {\n      let yNewBN = yBN.sub(getBigNumber(amountOut))\n      if (yNewBN.lt(1))\n        // lack of precision\n        yNewBN = BigNumber.from(1)\n\n      const xNewBN = HybridgetY(pool as RHybridPool, yNewBN)\n      input = Math.round(parseInt(xNewBN.sub(xBN).toString()) / (1 - pool.fee))\n\n      // const yNew = y - amountOut;\n      // const xNew = HybridgetY(pool, yNew);\n      // input = (xNew - x)/(1-pool.fee);\n      break\n    }\n    default:\n      console.error('Unknown pool type')\n  }\n\n  // ASSERT(() => {\n  //   const amount2 = calcOutByIn(pool, input, direction);\n  //   const res = closeValues(amountOut, amount2, 1e-6);\n  //   if (!res) console.log(\"Error 138:\", amountOut, amount2, Math.abs(amountOut/amount2 - 1));\n  //   return res;\n  // });\n  if (input < 1) input = 1\n  return input\n}\n\nexport function calcPrice(pool: Pool, amountIn: number, takeFeeIntoAccount = true): number {\n  const r0 = parseInt(pool.reserve0.toString())\n  const r1 = parseInt(pool.reserve1.toString())\n  const oneMinusFee = takeFeeIntoAccount ? 1 - pool.fee : 1\n  switch (pool.type) {\n    case PoolType.ConstantProduct: {\n      const x = r0 / oneMinusFee\n      return (r1 * x) / (x + amountIn) / (x + amountIn)\n    }\n    case PoolType.Weighted: {\n      const wPool = pool as RWeightedPool\n      const weightRatio = wPool.weight0 / wPool.weight1\n      const x = r0 + amountIn * oneMinusFee\n      return (r1 * weightRatio * oneMinusFee * Math.pow(r0 / x, weightRatio)) / x\n    }\n    case PoolType.Hybrid: {\n      const hPool = pool as RHybridPool\n      const D = parseInt(HybridComputeLiquidity(hPool).toString())\n      const A = hPool.A / A_PRECISION\n      const x = r0 + amountIn\n      const b = 4 * A * x + D - 4 * A * D\n      const ac4 = (D * D * D) / x\n      const Ds = Math.sqrt(b * b + 4 * A * ac4)\n      const res = (0.5 - (2 * b - ac4 / x) / Ds / 4) * oneMinusFee\n      return res\n    }\n  }\n  return 0\n}\n\nfunction calcInputByPriceConstantMean(pool: RWeightedPool, price: number) {\n  const r0 = parseInt(pool.reserve0.toString())\n  const r1 = parseInt(pool.reserve1.toString())\n  const weightRatio = pool.weight0 / pool.weight1\n  const t = r1 * price * weightRatio * (1 - pool.fee) * Math.pow(r0, weightRatio)\n  return (Math.pow(t, 1 / (weightRatio + 1)) - r0) / (1 - pool.fee)\n}\n\nexport function calcInputByPrice(pool: Pool, priceEffective: number, hint = 1): number {\n  switch (pool.type) {\n    case PoolType.ConstantProduct: {\n      const r0 = parseInt(pool.reserve0.toString())\n      const r1 = parseInt(pool.reserve1.toString())\n      const x = r0 / (1 - pool.fee)\n      const res = Math.sqrt(r1 * x * priceEffective) - x\n      return res\n    }\n    case PoolType.Weighted: {\n      const res = calcInputByPriceConstantMean(pool as RWeightedPool, priceEffective)\n      return res\n    }\n    case PoolType.Hybrid: {\n      return revertPositive((x: number) => 1 / calcPrice(pool, x), priceEffective, hint)\n    }\n  }\n  return 0\n}\n"],"names":["ASSERT","f","t","console","error","closeValues","a","b","accuracy","Math","abs","revertPositive","out","hint","min","max","x0","y0","e","getBigNumber","value","v","Number","MAX_SAFE_INTEGER","BigNumber","from","round","exp","floor","log","LN2","assert","shift","mant","pow","res","mul","RouteStatus","RPool","address","token0","token1","fee","reserve0","reserve1","minLiquidity","swapGasCost","this","updateReserves","res0","res1","ConstantProductRPool","reserve0Number","parseInt","toString","reserve1Number","calcOutByIn","amountIn","direction","gasSpent","calcInByOut","amountOut","inp","calcCurrentPriceWithoutFee","calcPrice","takeFeeIntoAccount","xf","calcInputByPrice","price","sqrt","getLiquidity","HybridRPool","A","D","computeLiquidity","eq","r0","r1","isZero","prevD","s","add","nA","i","dP","div","A_PRECISION","sub","lte","computeY","x","yPrev","c","y","yBN","xNewBN","yNewBN","xBN","lt","oneMinusFee","xI","ac4","_this3","CLRPool","tickSpacing","liquidity","sqrtPrice","nearestTick","ticks","_this","length","push","index","DLiquidity","unshift","nextTickToCross","currentPrice","currentLiquidity","outAmount","input","nextTickPrice","output","maxDx","maxDy","outBeforeFee","p","PoolType","Edge","v0","v1","pool","vert0","vert1","amountInPrevious","amountOutPrevious","canBeUsed","spentGas","spentGasNew","bestEdgeIncome","cleanTmpData","reserve","calcOutput","gas","calcInput","checkMinimalLiquidityExceededAfterSwap","testApply","directionNew","inPrev","outPrev","amountInNew","amountOutNew","getNeibour","inNew","outNew","calc","applySwap","to","bestIncome","Vertice","token","edges","gasPrice","bestTotal","bestSource","undefined","checkLine","getOutputEdges","filter","_this2","getInputEdges","Graph","pools","baseToken","vertices","tokens","Map","forEach","_this4","getOrCreateVertice","edge","baseVert","get","setPricesStable","edgeValues","addVertice","newEdges","set","sort","e1","e2","nextEdges","bestEdge","pop","vFrom","vTo","setPrices","map","_this5","vert","findBestPathExactIn","_gasPrice","start","finish","processedVert","Set","nextVertList","closestVert","closestTotal","closestPosition","bestPath","_v","path","totalOutput","splice","v2","has","newIncome","isFinite","newGasSpent","newTotal","findBestPathExactOut","_v2","totalInput","addPath","_from","_this6","every","total","totalModule","getPrimaryPriceForPath","prevToken","edgePrice","findBestRouteExactIn","mode","routeValues","Array","isArray","sum","reduce","primaryPrice","step","status","gasSpentInit","totalrouted","NoWay","fromToken","toToken","amountInBN","amountOutBN","legs","totalAmountOut","totalAmountOutBN","Partial","Success","swapPrice","priceImpact","fromVert","toVert","getRouteLegs","topologyWasChanged","calcLegsAmountOut","findBestRouteExactOut","calcLegsAmountIn","cleanTopology","n","outEdges","_this7","edgeFrom","amount","quantity","poolAddress","poolFee","tokenFrom","tokenTo","assumedAmountIn","assumedAmountOut","swapPortion","absolutePortion","amounts","l","_this8","find","inputTotal","vertNext","prevAmount","totalOutputAssumed","prevValue","_this9","outputTotal","totalAssumed","result","topologySort","removeWeakestEdge","removeDeadEnds","verts","minVert","minVertNext","minOutput","MAX_VALUE","vertState","vertsFinished","foundCycle","foundDeadEndVerts","topSortRecursive","current","state","successors2Exist","reverse","calcBestFlowNumber","bestSingleRoute","gasPriceIn","route","oneMinusCombinedFee","calcPriceImactWithoutFee","bestFlowAmount","bestFlowNumber","Pool","_info","info","type","RConstantProductPool","_Pool","ConstantProduct","RHybridPool","Hybrid","RWeightedPool","Weighted","weight0","weight1","RConcentratedLiquidityPool","ConcentratedLiquidity","DCacheBN","HybridComputeLiquidity","HybridgetY","OutOfLiquidity","Error","weightRatio","hPool","priceEffective","calcInputByPriceConstantMean","sqrtD","g","flows","fromV","outSingle","route1","route2","inSingle","getBetterRouteExactOut"],"mappings":"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"}