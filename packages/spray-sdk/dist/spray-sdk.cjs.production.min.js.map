{"version":3,"file":"spray-sdk.cjs.production.min.js","sources":["../src/enums/Fee.ts","../src/constants/index.ts","../src/functions/computePoolInitCodeHash.ts","../src/functions/computeConstantProductPoolAddress.ts","../src/entities/ConstantProductPool.ts","../src/functions/convertPoolOrPairtoRPool.ts","../src/functions/computeHybridLiquidity.ts","../src/enums/PoolState.ts","../src/enums/RouteType.ts","../src/functions/computeHybridPoolAddress.ts","../src/entities/HybridPool.ts","../src/entities/Trade.ts","../src/functions/calcTokenPrices.ts","../src/functions/convertTinesSingleRouteToLegacyRoute.ts","../src/functions/findMultiRouteExactIn.ts","../src/functions/findMultiRouteExactOut.ts","../src/functions/findSingleRouteExactIn.ts","../src/functions/findSingleRouteExactOut.ts"],"sourcesContent":["// Fee - Tiers TBD\nexport enum Fee {\n  LOW = 1,\n  MEDIUM = 5,\n  DEFAULT = 30,\n  HIGH = 100,\n}\n","import { JSBI, ChainId, AddressMap } from '@champagneswap/core-sdk'\n\nexport const A_PRECISION = JSBI.BigInt(100)\nexport const MAX_FEE = JSBI.BigInt(10000)\n\nexport const ROUTER_ADDRESS: AddressMap = {\n  [ChainId.KOVAN]: '0x473Ef9B3e01E34b242b13F875b123E53208C88FA',\n  [ChainId.RINKEBY]: '0x473Ef9B3e01E34b242b13F875b123E53208C88FA',\n}\n","import { keccak256, pack } from '@ethersproject/solidity'\n\nimport { defaultAbiCoder } from '@ethersproject/abi'\n\nexport const computePoolInitCodeHash = ({\n  creationCode,\n  deployData,\n  masterDeployerAddress,\n}: {\n  creationCode: string\n  deployData: string\n  masterDeployerAddress: string\n}): string =>\n  keccak256(\n    ['bytes'],\n    [\n      pack(\n        ['bytes', 'bytes'],\n        [creationCode, defaultAbiCoder.encode(['bytes', 'address'], [deployData, masterDeployerAddress])]\n      ),\n    ]\n  )\n","import { ChainId, ChainKey, Token } from '@champagneswap/core-sdk'\n\nimport { Fee } from '../enums/Fee'\nimport EXPORTS from '@sushiswap/trident/exports/all.json'\nimport constantProductPoolArtifact from '@sushiswap/trident/artifacts/contracts/pool/ConstantProductPool.sol/ConstantProductPool.json'\nimport { computePoolInitCodeHash } from './computePoolInitCodeHash'\nimport { defaultAbiCoder } from '@ethersproject/abi'\nimport { getCreate2Address } from '@ethersproject/address'\nimport { keccak256 } from '@ethersproject/solidity'\n\nexport const computeConstantProductPoolAddress = ({\n  factoryAddress,\n  tokenA,\n  tokenB,\n  fee,\n  twap,\n}: {\n  factoryAddress: string\n  tokenA: Token\n  tokenB: Token\n  fee: Fee\n  twap: boolean\n}): string => {\n  // does safety checks\n  const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA]\n\n  const deployData = defaultAbiCoder.encode(\n    ['address', 'address', 'uint256', 'bool'],\n    [...[token0.address, token1.address].sort(), fee, twap]\n  )\n\n  // Compute init code hash based off the bytecode, deployData & masterDeployerAddress\n  const CONSTANT_PRODUCT_POOL_INIT_CODE_HASH = computePoolInitCodeHash({\n    creationCode: constantProductPoolArtifact.bytecode,\n    deployData,\n    masterDeployerAddress: EXPORTS[ChainId.KOVAN][ChainKey.KOVAN].contracts.MasterDeployer.address,\n  })\n\n  // Compute pool address\n  return getCreate2Address(factoryAddress, keccak256(['bytes'], [deployData]), CONSTANT_PRODUCT_POOL_INIT_CODE_HASH)\n}\n","import {\n  ChainId,\n  ChainKey,\n  CurrencyAmount,\n  InsufficientInputAmountError,\n  InsufficientReservesError,\n  MINIMUM_LIQUIDITY,\n  ONE,\n  Price,\n  Token,\n  ZERO,\n  sqrt,\n} from '@champagneswap/core-sdk'\nimport { Fee } from '../enums/Fee'\nimport JSBI from 'jsbi'\nimport { MAX_FEE } from '../constants'\nimport EXPORTS from '@sushiswap/trident/exports/all.json'\nimport { computeConstantProductPoolAddress } from '../functions/computeConstantProductPoolAddress'\nimport invariant from 'tiny-invariant'\nimport { Pool } from './Pool'\n\nexport class ConstantProductPool implements Pool {\n  public readonly liquidityToken: Token\n  public readonly fee: Fee\n  public readonly twap: boolean\n  private readonly tokenAmounts: [CurrencyAmount<Token>, CurrencyAmount<Token>]\n\n  public static getAddress(tokenA: Token, tokenB: Token, fee: Fee = Fee.DEFAULT, twap: boolean = true): string {\n    return computeConstantProductPoolAddress({\n      factoryAddress: EXPORTS[ChainId.KOVAN][ChainKey.KOVAN].contracts.ConstantProductPoolFactory.address,\n      tokenA,\n      tokenB,\n      fee,\n      twap,\n    })\n  }\n\n  public constructor(\n    currencyAmountA: CurrencyAmount<Token>,\n    currencyAmountB: CurrencyAmount<Token>,\n    fee: Fee = Fee.DEFAULT,\n    twap: boolean = true\n  ) {\n    const currencyAmounts = currencyAmountA.currency.sortsBefore(currencyAmountB.currency) // does safety checks\n      ? [currencyAmountA, currencyAmountB]\n      : [currencyAmountB, currencyAmountA]\n    this.liquidityToken = new Token(\n      currencyAmounts[0].currency.chainId,\n      ConstantProductPool.getAddress(currencyAmounts[0].currency, currencyAmounts[1].currency, fee, twap),\n      18,\n      'SLP',\n      'Sushi LP Token'\n    )\n    this.fee = fee\n    this.twap = twap\n    this.tokenAmounts = currencyAmounts as [CurrencyAmount<Token>, CurrencyAmount<Token>]\n  }\n\n  /**\n   * Returns true if the token is either token0 or token1\n   * @param token to check\n   */\n  public involvesToken(token: Token): boolean {\n    return token.equals(this.token0) || token.equals(this.token1)\n  }\n\n  /**\n   * Returns the current mid price of the pair in terms of token0, i.e. the ratio of reserve1 to reserve0\n   */\n  public get token0Price(): Price<Token, Token> {\n    const result = this.tokenAmounts[1].divide(this.tokenAmounts[0])\n    return new Price(this.token0, this.token1, result.denominator, result.numerator)\n  }\n\n  /**\n   * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1\n   */\n  public get token1Price(): Price<Token, Token> {\n    const result = this.tokenAmounts[0].divide(this.tokenAmounts[1])\n    return new Price(this.token1, this.token0, result.denominator, result.numerator)\n  }\n\n  /**\n   * Return the price of the given token in terms of the other token in the pair.\n   * @param token token to return price of\n   */\n  public priceOf(token: Token): Price<Token, Token> {\n    invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.token0Price : this.token1Price\n  }\n\n  /**\n   * Returns the chain ID of the tokens in the pair.\n   */\n  public get chainId(): number {\n    return this.token0.chainId\n  }\n\n  public get token0(): Token {\n    return this.tokenAmounts[0].currency\n  }\n\n  public get token1(): Token {\n    return this.tokenAmounts[1].currency\n  }\n\n  public get reserve0(): CurrencyAmount<Token> {\n    return this.tokenAmounts[0]\n  }\n\n  public get reserve1(): CurrencyAmount<Token> {\n    return this.tokenAmounts[1]\n  }\n\n  public get assets(): Token[] {\n    return [this.tokenAmounts[0].currency, this.tokenAmounts[1].currency]\n  }\n\n  public get reserves(): CurrencyAmount<Token>[] {\n    return [this.reserve0, this.reserve1]\n  }\n\n  public get kLast(): JSBI {\n    return sqrt(this.reserve0.multiply(this.reserve1).quotient)\n  }\n\n  public reserveOf(token: Token): CurrencyAmount<Token> {\n    invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.reserve0 : this.reserve1\n  }\n\n  public getOutputAmount(inputAmount: CurrencyAmount<Token>): [CurrencyAmount<Token>, ConstantProductPool] {\n    invariant(this.involvesToken(inputAmount.currency), 'TOKEN')\n    if (JSBI.equal(this.reserve0.quotient, ZERO) || JSBI.equal(this.reserve1.quotient, ZERO)) {\n      throw new InsufficientReservesError()\n    }\n    const inputReserve = this.reserveOf(inputAmount.currency)\n    const outputReserve = this.reserveOf(inputAmount.currency.equals(this.token0) ? this.token1 : this.token0)\n    const inputAmountWithFee = JSBI.multiply(inputAmount.quotient, JSBI.subtract(MAX_FEE, JSBI.BigInt(this.fee)))\n    const numerator = JSBI.multiply(inputAmountWithFee, outputReserve.quotient)\n    const denominator = JSBI.add(JSBI.multiply(inputReserve.quotient, MAX_FEE), inputAmountWithFee)\n    const outputAmount = CurrencyAmount.fromRawAmount(\n      inputAmount.currency.equals(this.token0) ? this.token1 : this.token0,\n      JSBI.divide(numerator, denominator)\n    )\n    if (JSBI.equal(outputAmount.quotient, ZERO)) {\n      throw new InsufficientInputAmountError()\n    }\n    return [\n      outputAmount,\n      new ConstantProductPool(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount), this.fee, this.twap),\n    ]\n  }\n\n  public getInputAmount(outputAmount: CurrencyAmount<Token>): [CurrencyAmount<Token>, ConstantProductPool] {\n    invariant(this.involvesToken(outputAmount.currency), 'TOKEN')\n    if (\n      JSBI.equal(this.reserve0.quotient, ZERO) ||\n      JSBI.equal(this.reserve1.quotient, ZERO) ||\n      JSBI.greaterThanOrEqual(outputAmount.quotient, this.reserveOf(outputAmount.currency).quotient)\n    ) {\n      throw new InsufficientReservesError()\n    }\n\n    const outputReserve = this.reserveOf(outputAmount.currency)\n    const inputReserve = this.reserveOf(outputAmount.currency.equals(this.token0) ? this.token1 : this.token0)\n    const numerator = JSBI.multiply(JSBI.multiply(inputReserve.quotient, outputAmount.quotient), MAX_FEE)\n    const denominator = JSBI.multiply(\n      JSBI.subtract(outputReserve.quotient, outputAmount.quotient),\n      JSBI.subtract(MAX_FEE, JSBI.BigInt(this.fee))\n    )\n    const inputAmount = CurrencyAmount.fromRawAmount(\n      outputAmount.currency.equals(this.token0) ? this.token1 : this.token0,\n      JSBI.add(JSBI.divide(numerator, denominator), ONE)\n    )\n    return [\n      inputAmount,\n      new ConstantProductPool(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount), this.fee, this.twap),\n    ]\n  }\n\n  public getNonOptimalMintFee(amount0: JSBI, amount1: JSBI, reserve0: JSBI, reserve1: JSBI): [JSBI, JSBI] {\n    if (JSBI.equal(reserve0, ZERO) || JSBI.equal(reserve1, ZERO)) {\n      return [ZERO, ZERO]\n    }\n    const amount1Optimal = JSBI.divide(JSBI.multiply(amount0, reserve1), reserve0)\n\n    if (JSBI.lessThanOrEqual(amount1Optimal, amount1)) {\n      return [\n        ZERO,\n        JSBI.divide(\n          JSBI.multiply(JSBI.BigInt(this.fee), JSBI.subtract(amount1, amount1Optimal)),\n          JSBI.multiply(JSBI.BigInt(2), JSBI.BigInt(10000))\n        ),\n      ]\n    } else {\n      const amount0Optimal = JSBI.divide(JSBI.multiply(amount1, reserve0), reserve1)\n      return [\n        JSBI.divide(\n          JSBI.multiply(JSBI.BigInt(this.fee), JSBI.subtract(amount0, amount0Optimal)),\n          JSBI.multiply(JSBI.BigInt(2), JSBI.BigInt(10000))\n        ),\n        ZERO,\n      ]\n    }\n  }\n\n  public getMintFee(reserve0: JSBI, reserve1: JSBI, totalSupply: JSBI): JSBI {\n    console.log('getMintFee', {\n      kLast: this.kLast.toString(),\n      computed: sqrt(JSBI.multiply(reserve0, reserve1)).toString(),\n      totalSupply: totalSupply.toString(),\n    })\n\n    if (JSBI.notEqual(this.kLast, ZERO)) {\n      const computed = sqrt(JSBI.multiply(reserve0, reserve1))\n      if (JSBI.greaterThan(computed, this.kLast)) {\n        const liquidity = JSBI.divide(\n          JSBI.divide(\n            JSBI.multiply(JSBI.multiply(totalSupply, JSBI.subtract(computed, this.kLast)), JSBI.BigInt(5)),\n            computed\n          ),\n          JSBI.BigInt(10000)\n        )\n\n        console.log({\n          kLast: this.kLast.toString(),\n          computed: computed.toString(),\n          liquidity: liquidity.toString(),\n        })\n\n        if (JSBI.notEqual(liquidity, ZERO)) {\n          return liquidity\n        }\n      }\n    }\n\n    return ZERO\n  }\n\n  public getLiquidityMinted(\n    totalSupply: CurrencyAmount<Token>,\n    tokenAmountA: CurrencyAmount<Token>,\n    tokenAmountB: CurrencyAmount<Token>\n  ): CurrencyAmount<Token> {\n    invariant(totalSupply.currency.equals(this.liquidityToken), 'LIQUIDITY')\n    const tokenAmounts = tokenAmountA.currency.sortsBefore(tokenAmountB.currency) // does safety checks\n      ? [tokenAmountA, tokenAmountB]\n      : [tokenAmountB, tokenAmountA]\n    invariant(tokenAmounts[0].currency.equals(this.token0) && tokenAmounts[1].currency.equals(this.token1), 'TOKEN')\n\n    let liquidity: JSBI\n\n    // Expected balances after minting\n    const balance0 = JSBI.add(tokenAmounts[0].quotient, this.reserve0.quotient)\n    const balance1 = JSBI.add(tokenAmounts[1].quotient, this.reserve1.quotient)\n    const computed = sqrt(JSBI.multiply(balance0, balance1))\n\n    if (JSBI.equal(totalSupply.quotient, ZERO)) {\n      liquidity = JSBI.subtract(computed, MINIMUM_LIQUIDITY)\n    } else {\n\n      const [fee0, fee1] = this.getNonOptimalMintFee(\n        tokenAmounts[0].quotient,\n        tokenAmounts[1].quotient,\n        this.reserve0.quotient,\n        this.reserve1.quotient\n      )\n\n      const reserve0 = JSBI.add(this.reserve0.quotient, fee0)\n      const reserve1 = JSBI.add(this.reserve1.quotient, fee1)\n\n      const k = sqrt(JSBI.multiply(reserve0, reserve1))\n\n      const mintFee = this.getMintFee(reserve0, reserve1, totalSupply.quotient)\n\n      liquidity = JSBI.divide(JSBI.multiply(JSBI.subtract(computed, k), JSBI.add(totalSupply.quotient, mintFee)), k)\n\n    }\n\n    if (!JSBI.greaterThan(liquidity, ZERO)) {\n      throw new InsufficientInputAmountError()\n    }\n\n    return CurrencyAmount.fromRawAmount(this.liquidityToken, liquidity)\n  }\n\n  public getLiquidityValue(\n    token: Token,\n    totalSupply: CurrencyAmount<Token>,\n    liquidity: CurrencyAmount<Token>\n  ): CurrencyAmount<Token> {\n    invariant(this.involvesToken(token), 'TOKEN')\n    invariant(totalSupply.currency.equals(this.liquidityToken), 'TOTAL_SUPPLY')\n    invariant(liquidity.currency.equals(this.liquidityToken), 'LIQUIDITY')\n    invariant(JSBI.lessThanOrEqual(liquidity.quotient, totalSupply.quotient), 'LIQUIDITY')\n    return CurrencyAmount.fromRawAmount(\n      token,\n      JSBI.divide(JSBI.multiply(liquidity.quotient, this.reserveOf(token).quotient), totalSupply.quotient)\n    )\n  }\n\n  public getAmountOut(amountIn: JSBI, reserveAmountIn: JSBI, reserveAmountOut: JSBI): JSBI {\n    const amountInWithFee = JSBI.multiply(amountIn, JSBI.subtract(MAX_FEE, JSBI.BigInt(this.fee)))\n    return JSBI.divide(\n      JSBI.multiply(amountInWithFee, reserveAmountOut),\n      JSBI.add(JSBI.multiply(reserveAmountIn, MAX_FEE), amountInWithFee)\n    )\n  }\n\n  public getLiquidityValueSingleToken(\n    token: Token,\n    totalSupply: CurrencyAmount<Token>,\n    liquidity: CurrencyAmount<Token>\n  ): CurrencyAmount<Token> {\n    invariant(this.involvesToken(token), 'TOKEN')\n    invariant(totalSupply.currency.equals(this.liquidityToken), 'TOTAL_SUPPLY')\n    invariant(liquidity.currency.equals(this.liquidityToken), 'LIQUIDITY')\n    invariant(JSBI.lessThanOrEqual(liquidity.quotient, totalSupply.quotient), 'LIQUIDITY')\n\n    let _totalSupply = JSBI.add(\n      totalSupply.quotient,\n      this.getMintFee(this.reserve0.quotient, this.reserve1.quotient, totalSupply.quotient)\n    )\n    let amount0 = JSBI.divide(JSBI.multiply(liquidity.quotient, this.reserve0.quotient), _totalSupply)\n    let amount1 = JSBI.divide(JSBI.multiply(liquidity.quotient, this.reserve1.quotient), _totalSupply)\n\n    if (token === this.token1) {\n      return CurrencyAmount.fromRawAmount(\n        token,\n        JSBI.add(\n          amount1,\n          this.getAmountOut(\n            amount0,\n            JSBI.subtract(this.reserve0.quotient, amount0),\n            JSBI.subtract(this.reserve1.quotient, amount1)\n          )\n        )\n      )\n    }\n\n    return CurrencyAmount.fromRawAmount(\n      token,\n      JSBI.add(\n        amount0,\n        this.getAmountOut(\n          amount1,\n          JSBI.subtract(this.reserve1.quotient, amount1),\n          JSBI.subtract(this.reserve0.quotient, amount0)\n        )\n      )\n    )\n  }\n}\n","import { BigNumber } from '@ethersproject/bignumber'\nimport { Pair } from '@champagneswap/core-sdk'\nimport { ConstantProductRPool, RPool, RToken } from '@champagneswap/castle'\nimport { Pool } from '../entities/Pool'\nimport { ConstantProductPool } from '../entities/ConstantProductPool'\nimport { Fee } from '../enums/Fee'\n\nexport function convertPoolOrPairtoRPool(pool: Pool | Pair): RPool {\n  if (pool instanceof ConstantProductPool) {\n    return new ConstantProductRPool(\n      pool.liquidityToken.address,\n      pool.assets[0].wrapped as RToken,\n      pool.assets[1].wrapped as RToken,\n      pool.fee / 10000,\n      BigNumber.from(pool.reserves[0].quotient.toString()),\n      BigNumber.from(pool.reserves[1].quotient.toString())\n    )\n  } else if (pool instanceof Pair) {\n    return new ConstantProductRPool(\n      pool.liquidityToken.address,\n      pool.token0 as RToken,\n      pool.token1 as RToken,\n      Fee.DEFAULT / 10000,\n      BigNumber.from(pool.reserve0.quotient.toString()),\n      BigNumber.from(pool.reserve1.quotient.toString())\n    )\n  } else {\n    throw new Error('Unsupported type of pool !!!')\n  }\n}\n","import { JSBI, ONE, ZERO, difference } from '@champagneswap/core-sdk'\n\nimport { A_PRECISION } from '../constants'\n\nexport function computeHybridLiquidity(reserve0: JSBI, reserve1: JSBI, a: JSBI): JSBI {\n  if (JSBI.equal(reserve0, ZERO) && JSBI.equal(reserve1, ZERO)) {\n    return ZERO\n  }\n\n  const s = JSBI.add(reserve0, reserve1)\n\n  const N_A = JSBI.multiply(a, JSBI.BigInt(2))\n\n  let prevD\n\n  let D = s\n\n  for (let i = 0; i < 256; i++) {\n    const dP = JSBI.divide(\n      JSBI.divide(JSBI.multiply(JSBI.divide(JSBI.multiply(D, D), reserve0), D), reserve1),\n      JSBI.BigInt(4)\n    )\n\n    prevD = D\n\n    D = JSBI.divide(\n      JSBI.multiply(JSBI.add(JSBI.divide(JSBI.multiply(N_A, s), A_PRECISION), JSBI.multiply(dP, JSBI.BigInt(2))), D),\n      JSBI.add(\n        JSBI.multiply(JSBI.subtract(JSBI.divide(N_A, A_PRECISION), JSBI.BigInt(1)), D),\n        JSBI.multiply(dP, JSBI.BigInt(3))\n      )\n    )\n\n    if (JSBI.lessThanOrEqual(difference(D, prevD), ONE)) {\n      break\n    }\n  }\n\n  return D\n}\n","export enum PoolState {\n  LOADING,\n  NOT_EXISTS,\n  EXISTS,\n  INVALID,\n}\n","export enum RouteType {\n  SinglePool = 'SinglePool',\n  SinglePath = 'SinglePath',\n  ComplexPath = 'ComplexPath',\n  Unknown = 'Unknown',\n}\n","import { ChainId, ChainKey, JSBI, Token } from '@champagneswap/core-sdk'\n\nimport { Fee } from '../enums/Fee'\nimport EXPORTS from '@sushiswap/trident/exports/all.json'\nimport hybridPoolArtifact from '@sushiswap/trident/artifacts/contracts/pool/HybridPool.sol/HybridPool.json'\nimport { computePoolInitCodeHash } from './computePoolInitCodeHash'\nimport { defaultAbiCoder } from '@ethersproject/abi'\nimport { getCreate2Address } from '@ethersproject/address'\nimport { keccak256 } from '@ethersproject/solidity'\n\nexport const computeHybridPoolAddress = ({\n  factoryAddress,\n  tokenA,\n  tokenB,\n  fee,\n  a,\n}: {\n  factoryAddress: string\n  tokenA: Token\n  tokenB: Token\n  fee: Fee\n  a: JSBI\n}): string => {\n  // does safety checks\n  const [token0, token1] = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA]\n\n  const deployData = defaultAbiCoder.encode(\n    ['address', 'address', 'uint256', 'uint256'],\n    [...[token0.address, token1.address].sort(), fee, a]\n  )\n\n  // Compute init code hash based off the bytecode, deployData & masterDeployerAddress\n  const HYBRID_POOL_INIT_CODE_HASH = computePoolInitCodeHash({\n    creationCode: hybridPoolArtifact.bytecode,\n    deployData,\n    masterDeployerAddress: EXPORTS[ChainId.KOVAN][ChainKey.KOVAN].contracts.MasterDeployer.address,\n  })\n\n  // Compute pool address\n  return getCreate2Address(factoryAddress, keccak256(['bytes'], [deployData]), HYBRID_POOL_INIT_CODE_HASH)\n}\n","import {\n  ChainId,\n  ChainKey,\n  CurrencyAmount,\n  InsufficientInputAmountError,\n  Price,\n  Token,\n  ZERO,\n} from '@champagneswap/core-sdk'\nimport { computeHybridLiquidity, computeHybridPoolAddress } from '../functions'\n\nimport { A_PRECISION } from '../constants'\nimport { Fee } from '../enums'\nimport JSBI from 'jsbi'\nimport EXPORTS from '@sushiswap/trident/exports/all.json'\nimport invariant from 'tiny-invariant'\nimport { Pool } from './Pool'\n\nexport class HybridPool implements Pool {\n  public readonly liquidityToken: Token\n  public readonly fee: Fee\n  public readonly a: JSBI\n  private readonly tokenAmounts: [CurrencyAmount<Token>, CurrencyAmount<Token>]\n  public static getAddress(tokenA: Token, tokenB: Token, fee: Fee = Fee.DEFAULT, a: JSBI = A_PRECISION): string {\n    return computeHybridPoolAddress({\n      factoryAddress: EXPORTS[ChainId.KOVAN][ChainKey.KOVAN].contracts.HybridPoolFactory.address,\n      tokenA,\n      tokenB,\n      fee,\n      a,\n    })\n  }\n\n  public constructor(\n    currencyAmountA: CurrencyAmount<Token>,\n    currencyAmountB: CurrencyAmount<Token>,\n    fee: Fee = Fee.DEFAULT,\n    a: JSBI = A_PRECISION\n  ) {\n    const currencyAmounts = currencyAmountA.currency.sortsBefore(currencyAmountB.currency) // does safety checks\n      ? [currencyAmountA, currencyAmountB]\n      : [currencyAmountB, currencyAmountA]\n\n    this.liquidityToken = new Token(\n      currencyAmounts[0].currency.chainId,\n      HybridPool.getAddress(currencyAmounts[0].currency, currencyAmounts[1].currency, fee, a),\n      18,\n      'SLP',\n      'Sushi LP Token'\n    )\n    this.fee = fee\n    this.a = a\n    this.tokenAmounts = currencyAmounts as [CurrencyAmount<Token>, CurrencyAmount<Token>]\n  }\n\n  /**\n   * Returns true if the token is either token0 or token1\n   * @param token to check\n   */\n  public involvesToken(token: Token): boolean {\n    return token.equals(this.token0) || token.equals(this.token1)\n  }\n\n  /**\n   * Returns the current mid price of the pair in terms of token0, i.e. the ratio of reserve1 to reserve0\n   */\n  public get token0Price(): Price<Token, Token> {\n    const result = this.tokenAmounts[1].divide(this.tokenAmounts[0])\n    return new Price(this.token0, this.token1, result.denominator, result.numerator)\n  }\n\n  /**\n   * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1\n   */\n  public get token1Price(): Price<Token, Token> {\n    const result = this.tokenAmounts[0].divide(this.tokenAmounts[1])\n    return new Price(this.token1, this.token0, result.denominator, result.numerator)\n  }\n\n  /**\n   * Return the price of the given token in terms of the other token in the pair.\n   * @param token token to return price of\n   */\n  public priceOf(token: Token): Price<Token, Token> {\n    invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.token0Price : this.token1Price\n  }\n\n  /**\n   * Returns the chain ID of the tokens in the pair.\n   */\n  public get chainId(): number {\n    return this.token0.chainId\n  }\n\n  public get token0(): Token {\n    return this.tokenAmounts[0].currency\n  }\n\n  public get token1(): Token {\n    return this.tokenAmounts[1].currency\n  }\n\n  public get assets(): Token[] {\n    return [this.tokenAmounts[0].currency, this.tokenAmounts[1].currency]\n  }\n\n  public get reserves(): CurrencyAmount<Token>[] {\n    return [this.reserve0, this.reserve1]\n  }\n\n  public get reserve0(): CurrencyAmount<Token> {\n    return this.tokenAmounts[0]\n  }\n\n  public get reserve1(): CurrencyAmount<Token> {\n    return this.tokenAmounts[1]\n  }\n\n  public reserveOf(token: Token): CurrencyAmount<Token> {\n    invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.reserve0 : this.reserve1\n  }\n\n  public getNonOptimalMintFee(amount0: JSBI, amount1: JSBI, reserve0: JSBI, reserve1: JSBI): [JSBI, JSBI] {\n    if (JSBI.equal(reserve0, ZERO) || JSBI.equal(reserve1, ZERO)) {\n      return [ZERO, ZERO]\n    }\n    const amount1Optimal = JSBI.divide(JSBI.multiply(amount0, reserve1), reserve0)\n\n    if (JSBI.lessThanOrEqual(amount1Optimal, amount1)) {\n      return [\n        ZERO,\n        JSBI.divide(\n          JSBI.multiply(JSBI.BigInt(this.fee), JSBI.subtract(amount1, amount1Optimal)),\n          JSBI.multiply(JSBI.BigInt(2), JSBI.BigInt(10000))\n        ),\n      ]\n    } else {\n      const amount0Optimal = JSBI.divide(JSBI.multiply(amount1, reserve0), reserve1)\n      return [\n        JSBI.divide(\n          JSBI.multiply(JSBI.BigInt(this.fee), JSBI.subtract(amount0, amount0Optimal)),\n          JSBI.multiply(JSBI.BigInt(2), JSBI.BigInt(10000))\n        ),\n        ZERO,\n      ]\n    }\n  }\n\n  public getLiquidityMinted(\n    totalSupply: CurrencyAmount<Token>,\n    tokenAmountA: CurrencyAmount<Token>,\n    tokenAmountB: CurrencyAmount<Token>\n  ): CurrencyAmount<Token> {\n    invariant(totalSupply.currency.equals(this.liquidityToken), 'LIQUIDITY')\n    const tokenAmounts = tokenAmountA.currency.sortsBefore(tokenAmountB.currency) // does safety checks\n      ? [tokenAmountA, tokenAmountB]\n      : [tokenAmountB, tokenAmountA]\n    invariant(tokenAmounts[0].currency.equals(this.token0) && tokenAmounts[1].currency.equals(this.token1), 'TOKEN')\n\n    // Expected balances after minting\n    const balance0 = JSBI.add(tokenAmounts[0].quotient, this.reserve0.quotient)\n    const balance1 = JSBI.add(tokenAmounts[1].quotient, this.reserve1.quotient)\n\n    const [fee0, fee1] = this.getNonOptimalMintFee(\n      tokenAmounts[0].quotient,\n      tokenAmounts[1].quotient,\n      this.reserve0.quotient,\n      this.reserve1.quotient\n    )\n\n    let liquidity: JSBI\n\n    const newLiquidity = computeHybridLiquidity(JSBI.subtract(balance0, fee0), JSBI.subtract(balance1, fee1), this.a)\n\n    if (JSBI.equal(totalSupply.quotient, ZERO)) {\n      liquidity = JSBI.subtract(newLiquidity, JSBI.BigInt(1000))\n    } else {\n      const oldLiquidity = computeHybridLiquidity(this.reserve0.quotient, this.reserve1.quotient, this.a)\n\n      liquidity = JSBI.divide(\n        JSBI.multiply(JSBI.subtract(newLiquidity, oldLiquidity), totalSupply.quotient),\n        oldLiquidity\n      )\n\n      // console.log({\n      //   oldLiquidity: oldLiquidity.toString(),\n      // })\n    }\n\n    // console.log({\n    //   tokenAmountA: tokenAmountA.quotient.toString(),\n    //   tokenAmountB: tokenAmountB.quotient.toString(),\n    //   totalSupply: totalSupply.quotient.toString(),\n    //   newLiquidity: newLiquidity.toString(),\n    //   liquidity: liquidity.toString(),\n    // })\n\n    if (!JSBI.greaterThan(liquidity, ZERO)) {\n      throw new InsufficientInputAmountError()\n    }\n\n    return CurrencyAmount.fromRawAmount(this.liquidityToken, liquidity)\n  }\n\n  public getLiquidityValue(\n    token: Token,\n    totalSupply: CurrencyAmount<Token>,\n    liquidity: CurrencyAmount<Token>\n  ): CurrencyAmount<Token> {\n    invariant(this.involvesToken(token), 'TOKEN')\n    invariant(totalSupply.currency.equals(this.liquidityToken), 'TOTAL_SUPPLY')\n    invariant(liquidity.currency.equals(this.liquidityToken), 'LIQUIDITY')\n    invariant(JSBI.lessThanOrEqual(liquidity.quotient, totalSupply.quotient), 'LIQUIDITY')\n    return CurrencyAmount.fromRawAmount(\n      token,\n      JSBI.divide(JSBI.multiply(liquidity.quotient, this.reserveOf(token).quotient), totalSupply.quotient)\n    )\n  }\n}\n","import { Currency, CurrencyAmount, Percent, Price, TradeType, ZERO, JSBI, Fraction, ONE } from '@champagneswap/core-sdk'\nimport { MultiRoute, RToken } from '@champagneswap/castle'\nimport invariant from 'tiny-invariant'\n\n/**\n * Represents a trade executed against a list of pools.\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\n */\nexport class Trade<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType> {\n  /**\n   * The route of the trade, i.e. which pools the trade goes through and the input/output currencies.\n   */\n  public readonly route: MultiRoute\n\n  /**\n   * The type of the trade, either exact in or exact out.\n   */\n  public readonly tradeType: TTradeType\n\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n  public readonly inputAmount: CurrencyAmount<TInput>\n  /**\n   * The output amount for the trade assuming no slippage.\n   */\n  public readonly outputAmount: CurrencyAmount<TOutput>\n\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public readonly executionPrice: Price<TInput, TOutput>\n\n  /**\n   * Constructs an exact in trade with the given amount in and route\n   * @param route route of the exact in trade\n   * @param amountIn the amount being passed in\n   */\n  public static exactIn<TInput extends Currency, TOutput extends Currency>(\n    route: MultiRoute\n  ): Trade<TInput, TOutput, TradeType.EXACT_INPUT> {\n    return new Trade(route, TradeType.EXACT_INPUT)\n  }\n\n  /**\n   * Constructs an exact out trade with the given amount out and route\n   * @param route route of the exact out trade\n   * @param amountOut the amount returned by the trade\n   */\n  public static exactOut<TInput extends Currency, TOutput extends Currency>(\n    route: MultiRoute\n  ): Trade<TInput, TOutput, TradeType.EXACT_OUTPUT> {\n    return new Trade(route, TradeType.EXACT_OUTPUT)\n  }\n\n  /**\n   * The percent difference between the mid price before the trade and the trade execution price.\n   */\n  public readonly priceImpact: Percent\n\n  public constructor(\n    route: MultiRoute,\n    // amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>,\n    tradeType: TTradeType\n  ) {\n    this.route = route\n    this.tradeType = tradeType\n\n    const amountIn = CurrencyAmount.fromRawAmount(route.fromToken as TInput, route.amountIn.toFixed(0))\n\n    const amountOut = CurrencyAmount.fromRawAmount(route.toToken as TOutput, route.amountOut.toFixed(0))\n\n    if (tradeType === TradeType.EXACT_INPUT) {\n      this.inputAmount = CurrencyAmount.fromFractionalAmount(\n        amountIn.currency,\n        amountIn.numerator,\n        amountIn.denominator\n      )\n      this.outputAmount = CurrencyAmount.fromFractionalAmount(\n        amountOut.currency,\n        amountOut.numerator,\n        amountOut.denominator\n      )\n    } else {\n      this.inputAmount = CurrencyAmount.fromFractionalAmount(\n        amountIn.currency,\n        amountOut.numerator,\n        amountOut.denominator\n      )\n      this.outputAmount = CurrencyAmount.fromFractionalAmount(\n        amountOut.currency,\n        amountIn.numerator,\n        amountIn.denominator\n      )\n    }\n\n    this.executionPrice = new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.inputAmount.quotient,\n      this.outputAmount.quotient\n    )\n\n    // this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount)\n\n    this.priceImpact = new Percent(JSBI.BigInt(0), JSBI.BigInt(10000))\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public minimumAmountOut(slippageTolerance: Percent): CurrencyAmount<TOutput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return this.outputAmount\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE)\n        .add(slippageTolerance)\n        .invert()\n        .multiply(this.outputAmount.quotient).quotient\n      return CurrencyAmount.fromRawAmount(this.outputAmount.currency, slippageAdjustedAmountOut)\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public maximumAmountIn(slippageTolerance: Percent): CurrencyAmount<TInput> {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return this.inputAmount\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE)\n        .add(slippageTolerance)\n        .multiply(this.inputAmount.quotient).quotient\n      return CurrencyAmount.fromRawAmount(this.inputAmount.currency, slippageAdjustedAmountIn)\n    }\n  }\n\n  public static bestTradeExactIn<TInput extends Currency, TOutput extends Currency>(\n    route: MultiRoute,\n    currencyAmountIn: CurrencyAmount<TInput>,\n    currencyOut: TOutput\n  ): Trade<TInput, TOutput, TradeType.EXACT_INPUT> {\n    return new Trade(\n      { ...route, fromToken: currencyAmountIn.currency as RToken, toToken: currencyOut as RToken },\n      TradeType.EXACT_INPUT\n    )\n  }\n\n  public static bestTradeExactOut<TInput extends Currency, TOutput extends Currency>(\n    route: MultiRoute,\n    currencyIn: TInput,\n    currencyAmountOut: CurrencyAmount<TOutput>\n  ): Trade<TInput, TOutput, TradeType.EXACT_OUTPUT> {\n    return new Trade(\n      { ...route, fromToken: currencyIn as RToken, toToken: currencyAmountOut.currency as RToken },\n      TradeType.EXACT_OUTPUT\n    )\n  }\n}\n","import { Pair, Price, Token } from '@champagneswap/core-sdk'\nimport { calcTokenPrices as TinesCalcTokenPrices, RToken } from '@champagneswap/castle'\nimport { convertPoolOrPairtoRPool } from './convertPoolOrPairtoRPool'\nimport { Pool } from '../entities/Pool'\n\nexport function calcTokenPrices<T extends Token>(\n  pools: (Pool | Pair)[],\n  baseToken: T\n): Record<string, Price<Token, T>> {\n  const map: Map<RToken, number> = TinesCalcTokenPrices(pools.map(convertPoolOrPairtoRPool), baseToken as RToken)\n  const res: Record<string, Price<Token, T>> = {}\n  Array.from(map.entries()).forEach(\n    ([token, price]) => (res[token.address] = new Price(token as Token, baseToken, 1e18, Math.round(price * 1e18)))\n  )\n  return res\n}\n","import { Currency, Pair, Route } from '@champagneswap/core-sdk'\nimport {\n\n  MultiRoute,\n\n} from '@champagneswap/castle'\n\nexport function convertTinesSingleRouteToLegacyRoute<TInput extends Currency, TOutput extends Currency>(\n  route: MultiRoute,\n  allPairs: Pair[],\n  input: TInput,\n  output: TOutput\n): Route<TInput, TOutput> {\n  const pairHash = new Map<string, Pair>()\n  allPairs.forEach((p) => pairHash.set(p.liquidityToken.address, p))\n  const pairs = route.legs.map((l) => {\n    const pair = pairHash.get(l.poolAddress)\n    if (pair === undefined) {\n      throw new Error('Internal Error 119')\n    }\n    return pair\n  })\n  return new Route(pairs, input, output)\n}\n","import { BigNumber } from '@ethersproject/bignumber'\nimport { Pair, Token } from '@champagneswap/core-sdk'\nimport { MultiRoute, RToken, findMultiRouteExactIn as TinesFindMultiRouteExactIn } from '@champagneswap/castle'\nimport { Pool } from '../entities/Pool'\nimport { convertPoolOrPairtoRPool } from './convertPoolOrPairtoRPool'\n\nexport function findMultiRouteExactIn(\n  from: Token,\n  to: Token,\n  amountIn: BigNumber | number,\n  pools: (Pool | Pair)[],\n  baseToken: Token,\n  gasPrice: number\n): MultiRoute {\n  return TinesFindMultiRouteExactIn(\n    from as RToken,\n    to as RToken,\n    amountIn,\n    pools.map(convertPoolOrPairtoRPool),\n    baseToken as RToken,\n    gasPrice\n  )\n}\n","import { BigNumber } from '@ethersproject/bignumber'\nimport { Pair, Token } from '@champagneswap/core-sdk'\nimport { findMultiRouteExactOut as TinesFindMultiRouteExactOut, MultiRoute, RToken } from '@champagneswap/castle'\nimport { Pool } from '../entities/Pool'\nimport { convertPoolOrPairtoRPool } from './convertPoolOrPairtoRPool'\n\nexport function findMultiRouteExactOut(\n  from: Token,\n  to: Token,\n  amountIn: BigNumber | number,\n  pools: (Pool | Pair)[],\n  baseToken: Token,\n  gasPrice: number\n): MultiRoute {\n  return TinesFindMultiRouteExactOut(\n    from as RToken,\n    to as RToken,\n    amountIn,\n    pools.map(convertPoolOrPairtoRPool),\n    baseToken as RToken,\n    gasPrice\n  )\n}\n","import { BigNumber } from '@ethersproject/bignumber'\nimport { Pair, Token } from '@champagneswap/core-sdk'\nimport { findSingleRouteExactIn as TinesFindSingleRouteExactIn, MultiRoute, RToken } from '@champagneswap/castle'\nimport { Pool } from '../entities/Pool'\nimport { convertPoolOrPairtoRPool } from './convertPoolOrPairtoRPool'\n\nexport function findSingleRouteExactIn(\n  from: Token,\n  to: Token,\n  amountIn: BigNumber | number,\n  pools: (Pool | Pair)[],\n  baseToken: Token,\n  gasPrice: number\n): MultiRoute {\n  return TinesFindSingleRouteExactIn(\n    from as RToken,\n    to as RToken,\n    amountIn,\n    pools.map(convertPoolOrPairtoRPool),\n    baseToken as RToken,\n    gasPrice\n  )\n}\n","import { BigNumber } from '@ethersproject/bignumber'\nimport { Pair, Token } from '@champagneswap/core-sdk'\nimport { findSingleRouteExactOut as TinesFindSingleRouteExactOut, MultiRoute, RToken } from '@champagneswap/castle'\nimport { Pool } from '../entities/Pool'\nimport { convertPoolOrPairtoRPool } from './convertPoolOrPairtoRPool'\n\nexport function findSingleRouteExactOut(\n  from: Token,\n  to: Token,\n  amountIn: BigNumber | number,\n  pools: (Pool | Pair)[],\n  baseToken: Token,\n  gasPrice: number\n): MultiRoute {\n  return TinesFindSingleRouteExactOut(\n    from as RToken,\n    to as RToken,\n    amountIn,\n    pools.map(convertPoolOrPairtoRPool),\n    baseToken as RToken,\n    gasPrice\n  )\n}\n"],"names":["Fee","A_PRECISION","JSBI","BigInt","MAX_FEE","ROUTER_ADDRESS","ChainId","KOVAN","RINKEBY","computePoolInitCodeHash","keccak256","pack","creationCode","defaultAbiCoder","encode","deployData","masterDeployerAddress","computeConstantProductPoolAddress","factoryAddress","tokenA","tokenB","fee","twap","sortsBefore","address","sort","CONSTANT_PRODUCT_POOL_INIT_CODE_HASH","constantProductPoolArtifact","bytecode","EXPORTS","ChainKey","contracts","MasterDeployer","getCreate2Address","ConstantProductPool","currencyAmountA","currencyAmountB","DEFAULT","currencyAmounts","currency","liquidityToken","Token","chainId","getAddress","tokenAmounts","ConstantProductPoolFactory","involvesToken","token","equals","this","token0","token1","priceOf","invariant","token0Price","token1Price","reserveOf","reserve0","reserve1","getOutputAmount","inputAmount","equal","quotient","ZERO","InsufficientReservesError","inputReserve","outputReserve","inputAmountWithFee","multiply","subtract","numerator","denominator","add","outputAmount","CurrencyAmount","fromRawAmount","divide","InsufficientInputAmountError","getInputAmount","greaterThanOrEqual","ONE","getNonOptimalMintFee","amount0","amount1","amount1Optimal","lessThanOrEqual","amount0Optimal","getMintFee","totalSupply","console","log","kLast","toString","computed","sqrt","notEqual","greaterThan","liquidity","getLiquidityMinted","tokenAmountA","tokenAmountB","balance0","balance1","MINIMUM_LIQUIDITY","fee1","k","mintFee","getLiquidityValue","getAmountOut","amountIn","reserveAmountIn","reserveAmountOut","amountInWithFee","getLiquidityValueSingleToken","_totalSupply","result","Price","convertPoolOrPairtoRPool","pool","ConstantProductRPool","assets","wrapped","BigNumber","from","reserves","Pair","Error","computeHybridLiquidity","a","prevD","s","N_A","D","i","dP","difference","PoolState","RouteType","computeHybridPoolAddress","HYBRID_POOL_INIT_CODE_HASH","hybridPoolArtifact","HybridPool","HybridPoolFactory","newLiquidity","oldLiquidity","Trade","route","tradeType","fromToken","toFixed","amountOut","toToken","TradeType","EXACT_INPUT","fromFractionalAmount","executionPrice","priceImpact","Percent","exactIn","exactOut","EXACT_OUTPUT","minimumAmountOut","slippageTolerance","lessThan","slippageAdjustedAmountOut","Fraction","invert","maximumAmountIn","slippageAdjustedAmountIn","bestTradeExactIn","currencyAmountIn","currencyOut","bestTradeExactOut","currencyIn","currencyAmountOut","pools","baseToken","map","TinesCalcTokenPrices","res","Array","entries","forEach","Math","round","allPairs","input","output","pairHash","Map","p","set","pairs","legs","l","pair","get","poolAddress","undefined","Route","to","gasPrice","TinesFindMultiRouteExactIn","TinesFindMultiRouteExactOut","TinesFindSingleRouteExactIn","TinesFindSingleRouteExactOut"],"mappings":"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"}